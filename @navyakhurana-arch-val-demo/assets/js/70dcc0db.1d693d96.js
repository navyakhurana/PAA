"use strict";(self.webpackChunkpaa_doc=self.webpackChunkpaa_doc||[]).push([[9595],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(a),d=r,h=u["".concat(l,".").concat(d)]||u[d]||m[d]||i;return a?n.createElement(h,o(o({ref:t},p),{},{components:a})):n.createElement(h,o({ref:t},p))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},37374:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=a(87462),r=(a(67294),a(3905));const i={},o="Resource Overview",s={unversionedId:"project-panel/basic/kyma-resources-helm/components/ResourceOverview",id:"project-panel/basic/kyma-resources-helm/components/ResourceOverview",title:"Resource Overview",description:"This SaaS sample application makes use of various Kubernetes as well as custom Kyma resource definitions. In this chapter, you will get a brief introduction to the various resources and links where to find further valuable information if required.",source:"@site/docs/project-panel/2-basic/8-kyma-resources-helm/components/ResourceOverview.md",sourceDirName:"project-panel/2-basic/8-kyma-resources-helm/components",slug:"/project-panel/basic/kyma-resources-helm/components/ResourceOverview",permalink:"/PAA/@navyakhurana-arch-val-demo/project-panel/basic/kyma-resources-helm/components/ResourceOverview",draft:!1,tags:[],version:"current",lastUpdatedBy:"Navya khurana",lastUpdatedAt:1694068051,formattedLastUpdatedAt:"Sep 7, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Helm Charts",permalink:"/PAA/@navyakhurana-arch-val-demo/project-panel/basic/kyma-resources-helm/components/HelmCharts"},next:{title:"Template Details",permalink:"/PAA/@navyakhurana-arch-val-demo/project-panel/basic/kyma-resources-helm/components/TemplateDetails"}},l={},c=[{value:"API Rule",id:"api-rule",level:2},{value:"Cluster Role",id:"cluster-role",level:2},{value:"ConfigMap",id:"configmap",level:2},{value:"Deployment",id:"deployment",level:2},{value:"Istio Service Mesh",id:"istio-service-mesh",level:2},{value:"Istio Data/Traffic Flow",id:"istio-datatraffic-flow",level:3},{value:"Authorization Policy",id:"authorization-policy",level:3},{value:"Destination Rule",id:"destination-rule",level:3},{value:"Request Authentication",id:"request-authentication",level:3},{value:"Service Entry",id:"service-entry",level:3},{value:"Sidecar",id:"sidecar",level:3},{value:"Virtual Service",id:"virtual-service",level:3},{value:"Job",id:"job",level:2},{value:"Network Policy",id:"network-policy",level:2},{value:"Ory",id:"ory",level:2},{value:"Pod Autoscaler",id:"pod-autoscaler",level:2},{value:"Pod Disruption Budget",id:"pod-disruption-budget",level:2},{value:"Role Binding",id:"role-binding",level:2},{value:"Secret",id:"secret",level:2},{value:"Service",id:"service",level:2},{value:"Service Account",id:"service-account",level:2},{value:"Service Binding",id:"service-binding",level:2},{value:"Service Instance",id:"service-instance",level:2}],p={toc:c},u="wrapper";function m(e){let{components:t,...i}=e;return(0,r.kt)(u,(0,n.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"resource-overview"},"Resource Overview"),(0,r.kt)("p",null,"This SaaS sample application makes use of various Kubernetes as well as custom Kyma resource definitions. In this chapter, you will get a brief introduction to the various resources and links where to find further valuable information if required. "),(0,r.kt)("p",null,"While you can find comprehensive details for all of these resources online, in this part of the tutorial, we try to explain the purpose of the components in relation to the given scenario - using our own words. So please understand, that our explanations might not necessarily match the official documentation content for all resources. If you find any inconsistencies, feel free to provide adjustments or recommendations using a pull request."),(0,r.kt)("p",null,"In the following visualizations, you can allocate most of the documented resources. Some of them, which are consumed most Pods in a similar fashion, have been removed from the high-level architecture diagram for readability purposes. Their usage is described in the secondary visualization."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"&lt;img src=&quot;./images/ResourceDetailsArch.png&quot; width=&quot;700&quot;/&gt;",src:a(84850).Z,width:"1716",height:"986"})),(0,r.kt)("p",null,"Our assumption is the following - if you understand the basic ideas and concepts of all resources in the context of our sample scenario, this will make it much easier for you to understand the comprehensive but very generic official documentations. If you are new to the Kyma and Kubernetes ecosphere (as we were to the beginning of this project), an explanation focused on an exemplary sample use-case is often more beneficial than pages of generic resource documentation. If you have never worked with ",(0,r.kt)("strong",{parentName:"p"},"Kubernetes")," before, we suggest to equip yourself with at least some ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/"},"basic concepts")," before you continue. Learn about Clusters, Nodes, Pods and how the basic Kubernetes resources relate to each other. This will ease your upcoming trip through our content. "),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"&lt;img src=&quot;./images/KymaObjectsGeneral.png&quot; width=&quot;700&quot;/&gt;",src:a(83977).Z,width:"1516",height:"820"})),(0,r.kt)("p",null,"Once you have gained some basic understanding of Kubernetes, we highly recommend getting started with the ",(0,r.kt)("a",{parentName:"p",href:"#deployment"},(0,r.kt)("strong",{parentName:"a"},"Deployment"))," resource type and continuing your journey with the ",(0,r.kt)("a",{parentName:"p",href:"#istio-service-mesh"},(0,r.kt)("strong",{parentName:"a"},"Istio Service Mesh")),", before deep-diving into topics like ",(0,r.kt)("a",{parentName:"p",href:"#service-account"},(0,r.kt)("strong",{parentName:"a"},"Service Accounts")),", ",(0,r.kt)("a",{parentName:"p",href:"#network-policy"},(0,r.kt)("strong",{parentName:"a"},"Network Policies"))," or ",(0,r.kt)("a",{parentName:"p",href:"#pod-autoscaler"},(0,r.kt)("strong",{parentName:"a"},"Horizontal Pod Autoscalers")),". Feel free to use the provided high-level architecture diagram, to follow along the path which an incoming request takes, when targeting the different components of the sample application."),(0,r.kt)("p",null,"So much for the introduction. Below you can find the alphabetical list of the most important resource types used in our sample application. Get your hands dirty and have fun! "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#resource-overview"},"Resource Overview"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#api-rule"},"API Rule")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#cluster-role"},"Cluster Role")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#configmap"},"ConfigMap")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#deployment"},"Deployment")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#istio-service-mesh"},"Istio Service Mesh"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#istio-datatraffic-flow"},"Istio Data/Traffic Flow")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#authorization-policy"},"Authorization Policy")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#destination-rule"},"Destination Rule")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#request-authentication"},"Request Authentication")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#service-entry"},"Service Entry")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#sidecar"},"Sidecar")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#virtual-service"},"Virtual Service")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#job"},"Job")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#network-policy"},"Network Policy")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#ory"},"Ory")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#pod-autoscaler"},"Pod Autoscaler")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#pod-disruption-budget"},"Pod Disruption Budget")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#role-binding"},"Role Binding")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#secret"},"Secret")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#service"},"Service")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#service-account"},"Service Account")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#service-binding"},"Service Binding")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#service-instance"},"Service Instance"))))),(0,r.kt)("h2",{id:"api-rule"},"API Rule"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more")," - ",(0,r.kt)("a",{parentName:"p",href:"https://kyma-project.io/docs/kyma/latest/05-technical-reference/00-custom-resources/apix-01-apirule"},"https://kyma-project.io/docs/kyma/latest/05-technical-reference/00-custom-resources/apix-01-apirule"))),(0,r.kt)("p",null,"This custom Kyma Resource allows you to simplify the public exposure of workloads. An API Rule will automatically setup a Istio ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," and so-called ",(0,r.kt)("a",{parentName:"p",href:"#ory"},"Ory")," rules. While the ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," handles the routing of traffic arriving through the so-called ",(0,r.kt)("a",{parentName:"p",href:"#istio-service-mesh"},"Istio")," Ingress Gateway, ",(0,r.kt)("a",{parentName:"p",href:"#ory"},"Ory")," facilitates the mutation of header values or to apply access policies like OAuth2 or JWT validation strategies. Please check the details of the respective components to learn more. "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"Access strategies are currently not being used in our scenario, as authentication and authorization take place within CAP workloads. The usage of ",(0,r.kt)("a",{parentName:"p",href:"#ory"},"Ory")," Mutators to set custom headers is being used as part of the Subscriber API Rules. ")),(0,r.kt)("p",null,"In our sample, API Rules are defined for the Application Router, the Backend Service, the API Service and the API Service Broker. Only the integration of SAP API Management makes use of a dedicated ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," definition instead of an API Rule. This results from the fact, that API Rules indeed simplify the process of exposing your workloads, nevertheless they do not provide all features that the native usage of ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Services")," offers (e.g., having different target routes for the same request host). "),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("p",null,"Upon deployment, the following Kyma API Rule definition will create an ",(0,r.kt)("a",{parentName:"p",href:"#istio-service-mesh"},"Istio")," ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," instance, defining traffic rules for the ",(0,r.kt)("a",{parentName:"p",href:"#istio-service-mesh"},"Istio")," Ingress Gateway ",(0,r.kt)("strong",{parentName:"p"},"sap-demo-gateway")," (defined in namespace ",(0,r.kt)("strong",{parentName:"p"},"demo-dns"),"). This ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," will route any traffic arriving for host ",(0,r.kt)("strong",{parentName:"p"},"susaas-router-default.sap-demo.com")," to the ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Cluster IP Service")," ",(0,r.kt)("strong",{parentName:"p"},"susaas-router")," on port ",(0,r.kt)("strong",{parentName:"p"},"5000"),". "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"As the usage of a custom domain is not part of the Basic Version, your gateway and host might look a bit different as the default Kyma domain will be used. Furthermore, you might see ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Services")," samples which are using the hostname instead of the FQDN (full qualified domain name) in the host field. We recommend to use the FQDN whenever possible, to prevent any unforeseen behavior caused by automated determination of the correct domain.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: gateway.kyma-project.io/v1beta1\nkind: APIRule\nmetadata:\n  name: susaas-router\nspec:\n  # The API Rule will handle requests arriving for this Istio Gateway\n  gateway: demo-dns/sap-demo-gateway\n  # The API Rule will handle all requests arriving for this host\n  host: susaas-router-default.sap-demo.com\n  rules:\n    # Traffic on all paths will be routed to the Cluster IP service\n    - methods:\n        - GET\n        - POST\n        - PUT\n        - DELETE\n        - HEAD\n      path: /.*\n      # "allow" strategy will disable Ory Oathkeeper for target routing\n      accessStrategies:\n        - handler: allow\n  # Cluster IP Service to which the traffic is routed\n  service:\n    name: susaas-router\n    port: 5000\n')),(0,r.kt)("p",null,"The generated ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service"),", which will look like below and is updated whenever you apply changes to the corresponding API Rule. "),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Important")," - "),(0,r.kt)("p",{parentName:"admonition"},"As ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," will be updated automatically, please do not apply manual changes to instances associated to API Rules. If the API Rule feature scope is not sufficient, please create a dedicated ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," instead!")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: susaas-router\nspec:\n  gateways:\n    - demo-dns/sap-demo-gateway\n  hosts:\n    - susaas-router-default.sap-demo.com\n  http:\n    - corsPolicy:\n        allowMethods:\n          - GET\n          - POST\n          - PUT\n          - DELETE\n          - PATCH\n      headers:\n        # Original target host is retained in header\n        request:\n          set:\n            x-forwarded-host: susaas-router-default.sap-demo.com\n      match:\n        - uri:\n            regex: /.*\n      route:\n        # Route traffic to the Cluster IP Service of the Application Router workload\n        - destination:\n            host: susaas-router.default.svc.cluster.local\n            port:\n              number: 5000\n          weight: 100\n")),(0,r.kt)("p",null,"The API Rules generated for the Subscriber Tenants during onboarding, will result in slightly different ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Services")," as they need to fulfill an additional requirement to inject an ",(0,r.kt)("strong",{parentName:"p"},"x-custom-host")," header. This header allows the usage of custom domains instead of the mostly cumbersome and random subaccount subdomains. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"...\n  try{\n    const access_strategy = {\n      path: '/.*',\n      methods: ['GET','POST','PUT','PATCH','DELETE','HEAD'],\n      accessStrategies: [{ handler: 'noop' }],\n      // Mutator definitions result in Ory Mutators handled by Ory Oathkeeper\n      mutators: [{\n        handler: 'header',\n        config: {\n          // Custom Header injected into request by Ory Oathkeeper\n          headers: {\n            // Sample value - subscriber-a1b2c3-susaas-router-default.sap-demo.com\n            \"x-custom-host\": `${subdomain}-${svcName}-${namespace}.${clusterDomain}`,\n          }\n        }\n      }]\n    };\n...\n")),(0,r.kt)("p",null,"A resulting ",(0,r.kt)("strong",{parentName:"p"},"API Rule")," and corresponding ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," based on the ",(0,r.kt)("strong",{parentName:"p"},"Ory Mutator")," definition above could look similar to the following."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"API Rule")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"For ",(0,r.kt)("strong",{parentName:"p"},"SaaS")," Tenant with subdomain ",(0,r.kt)("strong",{parentName:"p"},"subscriber-a1b2c3"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: gateway.kyma-project.io/v1beta1\nkind: APIRule\nmetadata:\n  name: susaas-tenant-e1771\nspec:\n  # Handle requests arriving for this Istio Gateway\n  gateway: demo-dns/sap-demo-gateway\n  # Handle requests for this custom Subscriber subdomain\n  host: subscriber.sap-demo.com\n  rules:\n    - methods:\n        - GET\n        - POST\n        - PUT\n        - DELETE\n        - HEAD\n      path: /.*\n      accessStrategies:\n        - handler: noop\n      mutators:\n        - config:\n            headers:\n              x-custom-host: subscriber-a1b2c3-susaas-router-default.sap-demo.com\n          handler: header\n      path: /.*\n  # Cluster IP Service the traffic is routed after passing Ory Oathkeeper\n  service:\n    name: susaas-router\n    port: 5000\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Virtual Service")," "),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"For ",(0,r.kt)("strong",{parentName:"p"},"SaaS")," Tenant with subdomain ",(0,r.kt)("strong",{parentName:"p"},"subscriber-a1b2c3"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: susaas-tenant-e1771-25rzp\nspec:\n  gateways: ["demo-dns/sap-demo-gateway"]\n  hosts: ["subscriber.sap-demo.com"]\n  http:\n    - headers:\n        # Original target host is retained in header\n        request:\n          set:\n            x-forwarded-host: subscriber.sap-demo.com\n      match:\n        - uri:\n            regex: /.*\n      route:\n        # Route traffic to the Cluster IP Service of Ory Oathkeeper\n        # x-custom-host header added by Ory Oathkeeper\n        - destination:\n            host: ory-oathkeeper-proxy.kyma-system.svc.cluster.local\n            port:\n              number: 4455\n          weight: 100\n')),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#ory"},"Ory")," Oathkeeper will apply the defined mutator by setting the ",(0,r.kt)("strong",{parentName:"p"},"x-custom-host")," header and forward traffic to the Application Router Cluster IP Service. Combined with the Application Router environment variable ",(0,r.kt)("strong",{parentName:"p"},"EXTERNAL_REVERSE_PROXY"),", this allows us to provide dynamic custom domains to Subscriber tenants, while retaining the original Tenant subdomain in the ",(0,r.kt)("strong",{parentName:"p"},"x-custom-host")," header to comply with our TENANT_HOST_PATTERN deriving the Tenant identifier. "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"}," Tenant-Host-Pattern: (.*)-susaas-router-default.sap-demo.com\nCustom Domain: subscriber.sap-demo.com",(0,r.kt)("br",{parentName:"p"}),"\n","X-Custom-Host: subscriber-a1b2c3-susaas-router-default.sap-demo.com",(0,r.kt)("br",{parentName:"p"}),"\n","Identified Tenant: ",(0,r.kt)("strong",{parentName:"p"},"subscriber-a1b2c3"))),(0,r.kt)("p",null,"Please note, as ",(0,r.kt)("a",{parentName:"p",href:"#ory"},"Ory")," is subject to depreciation, the header mutator feature will be replaced in a future release. A potential candidate might be the usage of respective Istio features.  "),(0,r.kt)("h2",{id:"cluster-role"},"Cluster Role"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more")," - ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/reference/access-authn-authz/rbac/#role-and-clusterrole"},"https://kubernetes.io/docs/reference/access-authn-authz/rbac/#role-and-clusterrole"))),(0,r.kt)("p",null,"A Cluster Role allows you to define a collection of custom permissions for your Cluster. In our sample scenario, this is essential for the creation of ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rules")," at runtime. Whenever a new Subscriber is onboarded to the Sustainable SaaS application, a new ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rule")," is created at runtime. This new Rule will expose a tenant-specific URI (e.g., customer-xyz.sap-demo.com) reachable from the public internet. If configured during subscription, the ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rule")," and the corresponding (auto-generated) ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," will act as an ",(0,r.kt)("em",{parentName:"p"},"External Reverse Proxy"),", allowing you to define custom domains, which do not necessarily match the subscriber's subaccount subdomain. "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"Check the ",(0,r.kt)("em",{parentName:"p"},"/srv/utils/apiRule.js")," coding to learn more. Additionally, the ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@sap/approuter#Configurations"},"Application Router documentation")," provides further information on the EXTERNAL_REVERSE_PROXY flag, which is enabled for the reverse proxy feature. ")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"&lt;img src=&quot;./images/KOCustomDomain.png&quot; width=&quot;400&quot;/&gt;",src:a(77127).Z,width:"734",height:"424"})),(0,r.kt)("p",null,"The required ",(0,r.kt)("a",{parentName:"p",href:"../../../../code/charts/sustainable-saas/charts/susaas-srv/templates/cluster-role.yaml"},"Cluster Role")," in oru sample scenario, contains permissions to create, delete and modify ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rules"),". This Cluster Role is assigned to a dedicated ",(0,r.kt)("a",{parentName:"p",href:"#service-account"},"Service Account")," using a so-called ",(0,r.kt)("a",{parentName:"p",href:"#role-binding"},"Role Binding"),". In our example, the Cluster Role is bound to a ",(0,r.kt)("a",{parentName:"p",href:"#service-account"},"Service Account"),", which is (in turn) assigned to the SaaS Backend Application workload (Pod). At runtime, the Backend Application can interact with the Kyma Cluster on behalf of this ",(0,r.kt)("a",{parentName:"p",href:"#service-account"},"Service Account"),", as the respective ",(0,r.kt)("a",{parentName:"p",href:"#service-account"},"Service Account")," token is so-called auto-mounted to the workload. "),(0,r.kt)("p",null,"Auto-mounting a ",(0,r.kt)("a",{parentName:"p",href:"#service-account"},"Service Account")," token to your workload, lets you fetch the credentials to connect to the Cluster API as follows (Node.js): "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"  const kc = new k8s.KubeConfig();\n  kc.loadFromCluster();\n  ...\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"Check out the ",(0,r.kt)("a",{parentName:"p",href:"#deployment"},"Deployment")," section of this tutorial to learn more about the binding of ",(0,r.kt)("a",{parentName:"p",href:"#service-account"},"Service Accounts")," to a workload and how a ",(0,r.kt)("a",{parentName:"p",href:"#service-account"},"Service Account")," token can be auto-mounted for usage at runtime. ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: susaas-srv\nrules:\n  - apiGroups: ["gateway.kyma-project.io"]\n    resources: ["apirules"]\n    verbs:\n      - create\n      - delete\n      - get\n      - list\n      - patch\n      - update\n      - watch\n  - apiGroups:  ["gateway.kyma-project.io"]\n    resources: ["apirules/status"]\n    verbs: ["get"]\n')),(0,r.kt)("h2",{id:"configmap"},"ConfigMap"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more")," - ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/configuration/configmap/"},"https://kubernetes.io/docs/concepts/configuration/configmap/"))),(0,r.kt)("p",null,"A ConfigMap allows you to provide additional (configuration) information to your workloads like in our scenario the details of the Service Broker configuration. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: susaas-broker-config\ndata:\n  serviceConfigs: | \n    {   \n      "susaas-api-susaas-default-a1b2c3d4": {\n        "extend_credentials": {\n          "shared": {\n              "apiUrl": "https://susaas-api-default.sap-demo.com"\n            }\n        },\n        "extend_catalog": {\n          "metadata": {\n              "displayName": "Sustainable SaaS API"\n          }\n        }\n      }\n    }\n')),(0,r.kt)("p",null,"ConfigMaps can e.g., be referenced in your workload or replication controller definitions like ",(0,r.kt)("a",{parentName:"p",href:"#deployment"},"Deployments"),". In our sample scenario, a ConfigMap serves as dynamic content provider for an environment variable of our Service Broker (required on startup). Using ConfigMaps, we can keep our configurations dynamic and flexible by using Helm templates for references or ",(0,r.kt)("a",{parentName:"p",href:"#deployment"},"Deployment"),"-specific variables (like the namespace or the domain in the apiUrl)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: susaas-broker\nspec:\n  ...\n    spec:\n      ...\n      containers:\n      - image: sapse/susaas-broker:latest\n        ...\n        env:\n        - name: SBF_SERVICE_CONFIG\n          valueFrom:\n            configMapKeyRef:\n              name: susaas-broker-config\n              key: serviceConfigs\n")),(0,r.kt)("p",null,"Another interesting scenario is the mounting of ConfigMaps into the file system of a container. In our sample scenario, the API Service Broker requires access to a so-called ",(0,r.kt)("em",{parentName:"p"},"catalog.json")," file on startup. This file contains information on available service plans, and the content cannot be provided as environment variable. Instead, the respective environment variable SBF_CATALOG_FILE expects a path pointing to the ",(0,r.kt)("em",{parentName:"p"},"catalog.json")," file. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: susaas-broker-catalog\ndata:\n  # File name which will be created when mounted to container file system\n  catalog.json: | \n    {\n        "services": [{\n            ...\n')),(0,r.kt)("p",null,"Mounting this ConfigMap to the file system of a container, will create a respective ",(0,r.kt)("em",{parentName:"p"},"catalog.json")," file in the ",(0,r.kt)("em",{parentName:"p"},"/etc/config")," path. This path is then being referenced in the environment variable. "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"The file name is based on the property value ",(0,r.kt)("strong",{parentName:"p"},"catalog.json")," in your ConfigMap instance. ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: susaas-broker\nspec:\n  ...\n    spec:\n      ...\n      containers:\n      - image: sapse/susaas-broker:latest\n        ...\n        env:\n        # Provide path of generated file to env variable\n        - name: SBF_CATALOG_FILE\n          value: "/etc/config/catalog.json"\n        ...\n        # Mount available volume to dedicated path\n        volumeMounts:\n        - name: susaas-broker-catalog\n          mountPath: "/etc/config"\n          readOnly: true\n        ...\n      ...\n      # Define ConfigMap as volume in your workload\n      volumes:\n        - name: susaas-broker-catalog\n          configMap: \n            name: susaas-broker-catalog\n')),(0,r.kt)("p",null,"Again, in case you wonder why we are not providing the catalog.json file as part of our API Service Broker Docker Image. The above approach allows us to keep the Docker Image for the API Service Broker extremely dynamic and pass the required instance properties upon deployment, based on the respective environment details. "),(0,r.kt)("h2",{id:"deployment"},"Deployment"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more")," - ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/"},"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/"))),(0,r.kt)("p",null,"Deployments contain the core definitions of your workloads (Pods). Instead of directly creating ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/workloads/pods/"},"Pods")," or ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/"},"Replica Sets")," in your Cluster, you should make use of Deployments whenever possible. A Deployment will automatically instantiate Replica Sets and Pods based on the workload definition in your Deployment configuration. "),(0,r.kt)("p",null,"A major advantage of Deployments is the fact, that associated Replica Sets will automatically be re-instantiate, in case you deletion. Furthermore, a Replica Set will always spin up new Pods as defined in your Deployment specification, whenever an instance is deleted/terminated. So instead of creating dedicated Replica Sets or Pods, the general recommendation is to make use of Deployments. Those will manage respective Replica Sets, which again will manage the associated Pods for you.  "),(0,r.kt)("p",null,"Before getting your head around Deployments, lets take a quick detour and understand the usage of Volumes, how they can be referenced in your Pods and mounted to your Containers. "),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Volumes")),(0,r.kt)("p",null,"To understand the usage of Volumes, let us go one step back to the Pod level. You can imagine a Pod being a little computer running a certain application. This application can consist of several containers, which are handling the different application processes. "),(0,r.kt)("p",null,"All containers share the resources of the Pod they are running in. This includes Network Components, CPU, RAM or other compute resources. But - unlike a normal computer (where processes also share the same file system), Containers in Pods behave differently. In a Pod, each Container has its own file system. While required Volumes are defined on Pod level, they are separately mounted into the file systems of the respective Containers. "),(0,r.kt)("p",null,"In this sample, Volumes are primarily being used to provide the SAP BTP ",(0,r.kt)("a",{parentName:"p",href:"#service-binding"},"Service Binding")," credentials to our workloads. By mounting those Volumes to a predefined path called ",(0,r.kt)("em",{parentName:"p"},"/bindings/"),", frameworks like CAP are able to use the Service Bindings at runtime (",(0,r.kt)("a",{parentName:"p",href:"https://blogs.sap.com/2022/07/12/the-new-way-to-consume-service-bindings-on-kyma-runtime/"},"click here")," to learn more). To find different examples of how to use Volumes e.g., for ",(0,r.kt)("a",{parentName:"p",href:"#config-map"},"ConfigMaps"),", please visit the ",(0,r.kt)("a",{parentName:"p",href:"#config-map"},"respective chapter")," in this tutorial. "),(0,r.kt)("p",null,"So much for the introduction of Deployments and Volumes. Let us check out a concrete sample - in this case for the Application Router Deployment."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: susaas-router\nspec:\n  selector:\n    matchLabels:\n      app.kubernetes.io/name: router\n  template:\n    metadata:\n      labels:\n        app.kubernetes.io/name: router\n    # Specification of Pod / Workload\n    spec:\n      # Define if Service Account token shall be auto-mounted to Pod\n      # Necessary if interaction with Cluster required at runtime\n      automountServiceAccountToken: false\n      # Service Account name (also "default" Service Account possible)\n      serviceAccountName: susaas-router\n      # Container(s) to run within Pods of this deployment\n      # Istio Sidecar will be injected automatically \n      containers:\n        # Definition of Container running in the Pod\n        - image: sapse/susaas-router:latest\n          name: router\n          # Port and protocol this container exposes \n          ports:\n            - name: http\n              containerPort: 5000\n              protocol: TCP\n          # Environment Variables available during runtime\n          env:\n            # SAP BTP Service Bindings Volume mount path\n            - name: SERVICE_BINDING_ROOT\n              value: /bindings\n            - name: PORT\n              value: "5000"\n            - name: APPLICATION_NAME\n              value: susaas-router\n            # Tenant Host Pattern for multitenancy\n            - name: TENANT_HOST_PATTERN\n              value: "^(.*)-susaas-router-default"\n            # Enable External Reverse Proxy feature\n            - name: EXTERNAL_REVERSE_PROXY \n              value: "true"\n            # Additional environment variables required at runtime\n            - name: APPLICATION_URI\n              value: susaas-router\n            - name: KYMA_NAMESPACE\n              value: default\n          # Endpoints for Liveness, Readiness and Startup probes\n          livenessProbe:\n            # These endpoints should exist and return a 200 response code\n            # Otherwise, your Pods might not start successfully\n            httpGet:\n              path: /healthz\n              port: http\n          readinessProbe:\n            httpGet:\n              path: /healthz\n              port: http\n          startupProbe:\n            httpGet:\n              path: /healthz\n              port: http\n            failureThreshold: 15\n            periodSeconds: 2\n          # Volumes mounted to container incl. SAP BTP Service Bindings\n          # All SAP BTP Service Bindings are mounted on /bindings/ path\n          volumeMounts:\n            - mountPath: /bindings/destination/\n              name: "destination"\n              readOnly: true\n            - mountPath: /bindings/html5-apps-repo/\n              name: "html5-apps-repo"\n              readOnly: true\n            - mountPath: /bindings/xsuaa/\n              name: "xsuaa"\n              readOnly: true\n          # Resource configurations for Container\n          resources:\n            limits:\n              cpu: 300m\n              ephemeral-storage: 1G\n              memory: 500M\n            requests:\n              cpu: 300m\n              ephemeral-storage: 1G\n              memory: 500M\n          # Container security config additional to Pod level restrictions\n          securityContext:\n            allowPrivilegeEscalation: false\n            capabilities:\n              drop:\n                - ALL\n            privileged: false\n            readOnlyRootFilesystem: false\n      # Pod restart policy\n      restartPolicy: Always\n      # Security config applying to all containers in the Pod\n      securityContext:\n        runAsNonRoot: true\n        runAsUser: 1000\n      # Topology Spread Constraints control how Pods are allocated within your Cluster \n      # Allows you to define failure domains like "Nodes" to enable high-availability\n      topologySpreadConstraints:\n        - labelSelector:\n            matchLabels:\n              app.kubernetes.io/name: router\n          maxSkew: 1\n          topologyKey: kubernetes.io/hostname\n          whenUnsatisfiable: DoNotSchedule\n      # Volumes required by workload resources incl. SAP BTP Service Bindings\n      volumes:\n        - name: destination\n          secret:\n            secretName: susaas-router-destination\n        - name: html5-apps-repo\n          secret:\n            secretName: susaas-router-html5-apps-repo\n        - name: xsuaa\n          secret:\n            secretName: susaas-router-xsuaa\n')),(0,r.kt)("p",null,"To learn more about the topic of high availability and the ",(0,r.kt)("strong",{parentName:"p"},"topologySpreadCosntraints")," used as part of the auto-generated Deployment configurations, feel free to read the official Kubernetes documentation (",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/"},"click here"),")."),(0,r.kt)("h2",{id:"istio-service-mesh"},"Istio Service Mesh"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"https://istio.io/"},"https://istio.io/"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"https://istio.io/latest/docs/concepts/security/"},"https://istio.io/latest/docs/concepts/security/"))),(0,r.kt)("p",null,"Istio is among the most widely and adopted Service Mesh solutions for Kubernetes. Istio enriches your Cluster with features providing an uniform and efficient way to secure, connect, and monitor communication between your services and associated workloads. Istio is an Open Source project and comes pre-configured with your Kyma Cluster. In our sample, we are using Istio primarily to ensure a secure communication within the Cluster as well as for exposing the sample SaaS application to the public internet. This includes a variety of different components, which are described in closer detail in the upcoming sections. "),(0,r.kt)("p",null,"If you enable the ",(0,r.kt)("strong",{parentName:"p"},"Istio-Injection")," in a certain Kyma namespace (by setting the required namespace annotation), whenever you create a new Pod in that namespace, a so called Istio Sidecar ",(0,r.kt)("a",{parentName:"p",href:"https://istio.io/latest/docs/ops/deployment/architecture/#envoy"},"Proxy")," (based on ",(0,r.kt)("strong",{parentName:"p"},"Envoy")," - ",(0,r.kt)("a",{parentName:"p",href:"https://www.envoyproxy.io/"},"see details"),") will be automatically injected into the workload. This Proxy ensures that in- and outgoing communication between services (and associated workloads) always traverses through these Istio Proxies. For this purpose, Istio supports all kind of Kubernetes ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Service")," types, but in our scenario, we are always referring to a Cluster IP ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Service")," when talking about ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Services"),". To get a better understanding of how Proxies enrich and control the communication flow between workload, check out the following visualization taken from the official Istio documentation. "),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"&lt;img src=&quot;./images/IstioArchitecture.svg&quot; width=&quot;300&quot;/&gt;",src:a(62099).Z,width:"680",height:"475"}),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("em",{parentName:"p"},"Source: ",(0,r.kt)("a",{parentName:"em",href:"https://istio.io/latest/docs/ops/deployment/architecture/"},"https://istio.io/latest/docs/ops/deployment/architecture/"))),(0,r.kt)("p",null,"So you might ask yourself, what is the benefit of this additional Proxy handling the communication between services? Well, besides great traffic monitoring features, this architecture allows an encrypted, secure and transparent communication within or even across different Nodes of your Cluster, which otherwise could happen unencrypted (if not enforced by workload itself). Furthermore, Istio comes with a bagful of handy tools, that allow you to define traffic routing policies or authorization checks for your ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Services"),". To learn more about the idea of Sidecar Proxies and how so-called mutual TLS (mTLS) communication can be enforced across your Service Mesh, check out the following documentation (",(0,r.kt)("a",{parentName:"p",href:"https://istio.io/latest/docs/ops/configuration/traffic-management/tls-configuration/"},"click here"),"). "),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"&lt;img src=&quot;./images/IstioArchitectureDetails.svg&quot; width=&quot;500&quot;/&gt;",src:a(83794).Z,width:"1128",height:"536"}),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("em",{parentName:"p"},"Source: ",(0,r.kt)("a",{parentName:"em",href:"https://istio.io/latest/docs/concepts/security/"},"https://istio.io/latest/docs/concepts/security/"))),(0,r.kt)("p",null,"Besides handling ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Service")," to ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Service")," communication within your Cluster, Istio also simplifies workload exposure to external stakeholders. By positioning dedicated Envoy Proxy at the edge of your Cluster (called Gateway - ",(0,r.kt)("a",{parentName:"p",href:"https://istio.io/latest/docs/concepts/traffic-management/#gateways"},"see details"),"), Istio supports you in making ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Services")," reachable through the public internet in a secure manner. As a nice side-effect, it saves you from spending a lot of money on public IP addresses, as Load Balancer ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Services")," are not required anymore to expose your workloads. The below screenshot shows a sample of using a tool called ",(0,r.kt)("strong",{parentName:"p"},"Kiali")," (",(0,r.kt)("a",{parentName:"p",href:"https://kiali.io/"},"learn more"),"), to monitor traffic flows managed by Istio. "),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"&lt;img src=&quot;./images/KOKialiIstioIngress.png&quot; width=&quot;700&quot;/&gt;",src:a(99209).Z,width:"1905",height:"755"}),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("em",{parentName:"p"},"Source: ",(0,r.kt)("a",{parentName:"em",href:"https://istio.io/latest/docs/examples/microservices-istio/istio-ingress-gateway/"},"https://istio.io/latest/docs/examples/microservices-istio/istio-ingress-gateway/"))),(0,r.kt)("p",null,"The visualization contains a sample for such an (Ingress) Gateway, allowing external access to the ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Services")," in your Service Mesh. Istio provides an extremely powerful toolset and within this sample scenario, we are only using it to a very reduced scope. For productive workloads, it is essential to acquaint yourself in detail with the comprehensive Istio Documentation (",(0,r.kt)("a",{parentName:"p",href:"https://istio.io/latest/docs/"},"click here"),"). "),(0,r.kt)("h3",{id:"istio-datatraffic-flow"},"Istio Data/Traffic Flow"),(0,r.kt)("p",null,"To get a better understanding of how Istio manages the communication between your ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Services")," or any incoming external traffic, let us have another brief look at the data flow visualization and some high-level details provided below. Feel free to swing along and learn more about the different Istio components used to secure the interaction of external stakeholders with your workloads. "),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"&lt;img src=&quot;./images/ResourceDetailsArch.png&quot; width=&quot;700&quot;/&gt;",src:a(84850).Z,width:"1716",height:"986"})),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Ingress Traffic")),(0,r.kt)("p",null,"Let's check what is happening under the hood, when a request from the public internet arrives in our Kyma Cluster. This is the default case, whenever a user is opening the SaaS application in his browser or tries to reach out to the SaaS API endpoints (with an additional exception in case of SAP API Management usage)."),(0,r.kt)("p",null,"1) First of all, the request reaches the so-called Istio (Ingress) ",(0,r.kt)("strong",{parentName:"p"},"Gateway")," ",(0,r.kt)("a",{parentName:"p",href:"https://istio.io/latest/docs/concepts/traffic-management/#gateways"},"see details")," acting at the edge of the Service Mesh. "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"As mentioned, the Istio (Ingress) ",(0,r.kt)("a",{parentName:"p",href:"https://istio.io/latest/docs/concepts/traffic-management/#gateways"},"Gateway")," is another so-called ",(0,r.kt)("strong",{parentName:"p"},"Envoy"),"-based Proxy providing similar features as internal Sidecar Proxies. ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("a",{parentName:"p",href:"https://istio.io/latest/docs/concepts/traffic-management/#gateways"},"Gateway")," provides features like handling the TLS termination and ensures that any onward traffic targeting the mesh-internal ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Services")," is using mTLS (mutual TLS). ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"You can use multiple Istio (Ingress) Gateway instances in the same Service Mesh to e.g., handle incoming traffic different custom domains. ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Except for scenarios in which you need a custom domain in your Service Mesh, you can use the default Kyma Istio (Ingress) Gateway. "),(0,r.kt)("blockquote",{parentName:"li"},(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Istio-Documentation")," - You use a gateway to manage inbound and outbound traffic for your mesh, letting you specify which traffic you want to enter or leave the mesh. Gateway configurations are applied to standalone Envoy proxies that are running at the edge of the mesh, rather than sidecar Envoy Proxies running alongside your service workloads (",(0,r.kt)("a",{parentName:"p",href:"https://istio.io/latest/docs/concepts/traffic-management/#gateways"},"see details"),").")))),(0,r.kt)("p",null,"2) For routing traffic to the correct ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Service")," (and associated workloads) in the Service Mesh, Istio makes use of so-called ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},(0,r.kt)("strong",{parentName:"a"},"Virtual Services")),". "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Services")," define flexible rules, of how traffic is routed to ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Services")," within the Service Mesh. ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Besides mesh-internal ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Services"),", you can also route traffic to mesh-external services like SAP API Management using ",(0,r.kt)("a",{parentName:"p",href:"#service-entry"},"Service Entries"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"While not used in our sample scenario, ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Services")," can also be used for sophisticated mesh-internal routing requirements."),(0,r.kt)("admonition",{parentName:"li",type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"In this case ",(0,r.kt)("em",{parentName:"p"},"mesh")," needs to be added as a ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," Gateway and the corresponding target ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Service")," host value needs to be added like ",(0,r.kt)("em",{parentName:"p"},"susaas-router")," (or even better ",(0,r.kt)("em",{parentName:"p"},"susaas-router.default.svc.cluster.local"),")."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"In our sample scenario, ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Services")," are mostly auto-generated by so-called Kyma ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rules"),", hiding the Istio details from developers. For default scenarios, this is just fine and simplifies the whole routing and service exposure setup.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Only for the Integration of SAP API Management, a dedicated ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," is being used in our sample scenario. The feature scope offered by ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rules")," is not sufficient for this requirement. "),(0,r.kt)("blockquote",{parentName:"li"},(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Istio-Documentation")," - ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Services"),", along with ",(0,r.kt)("a",{parentName:"p",href:"#destination-rule"},"Destination Rules"),", are the key building blocks of Istio\u2019s traffic routing functionality. A ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," lets you configure how requests are routed to a service within an Istio Service Mesh, building on the basic connectivity and discovery provided by Istio and your platform. Each ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," consists of a set of routing rules that are evaluated in order, letting Istio match each given request to the ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," to a specific real destination within the mesh (",(0,r.kt)("a",{parentName:"p",href:"https://istio.io/latest/docs/concepts/traffic-management/#virtual-services"},"see details"),").")))),(0,r.kt)("p",null,"3) After identifying the correct routing target, so-called ",(0,r.kt)("a",{parentName:"p",href:"#destination-rule"},(0,r.kt)("strong",{parentName:"a"},"Destination Rules"))," come into play. "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#destination-rule"},"Destination Rules")," allow you to specify further traffic-related policies after successful routing. The rule you configured is applied on the destination given by your ",(0,r.kt)("a",{parentName:"li",href:"#virtual-service"},"Virtual Service"),".  "),(0,r.kt)("li",{parentName:"ul"},"In a lot of scenarios, this includes e.g., load-balancing between different subsets of a target workload.\n:::tip ",(0,r.kt)("strong",{parentName:"li"},"Hint"),"\nThis can be especially useful for A/B testing scenarios or ",(0,r.kt)("a",{parentName:"li",href:"https://istio.io/latest/docs/tasks/traffic-management/locality-load-balancing/failover/"},"locality failover scenarios"),".\n:::"),(0,r.kt)("li",{parentName:"ul"},"The source of the traffic (mesh internal or external) is not of importance for the ",(0,r.kt)("a",{parentName:"li",href:"#destination-rule"},"Destination Rule"),"."),(0,r.kt)("li",{parentName:"ul"},"In our sample scenario, Destination Rules are used to ensure session-stickiness for traffic targeting the Application Router. ",(0,r.kt)("admonition",{parentName:"li",type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"This ensures that clients are always routed to the same Pod based on a session cookie. ")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"  > **Istio-Documentation** - You can think of [Virtual Services](#virtual-service) as how you route your traffic to a given destination, and then you use [Destination Rules](#destination-rule) to configure what happens to traffic for that destination. [Destination Rules](#destination-rule) are applied after [Virtual Service](#virtual-service) routing rules are evaluated, so they apply to the traffic\u2019s \u201creal\u201d destination ([see details](https://istio.io/latest/docs/concepts/traffic-management/#destination-rules)).\n")))),(0,r.kt)("p",null,"4) Depending on your use-case, further Istio features are applied before a request finally reaches a target ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Service"),". "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"While ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Services")," and ",(0,r.kt)("a",{parentName:"p",href:"#destination-rule"},"Destination Rules")," are always tied to certain hosts and ensure proper routing to target ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Services"),", ",(0,r.kt)("a",{parentName:"p",href:"#request-authentication"},"Request Authentication")," and ",(0,r.kt)("a",{parentName:"p",href:"#authorization-policy"},"Authorization Policy")," definitions are applied to workloads. They specify what authentication methods are supported by workloads and enable access control on workloads in the Service Mesh. If desired, they can also be applied at e.g., namespace or even mesh-level (like enforcing mTLS across a Service Mesh). ")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If you need to validate whether a request is properly authenticated you can for example use ",(0,r.kt)("a",{parentName:"li",href:"#request-authentication"},(0,r.kt)("strong",{parentName:"a"},"Request Authentication")),".  ",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"In our scenario, this allows us to ensure that requests targeting the SaaS API Service, contain a valid JWT token, issued by the SAP XSUAA tenant of the Provider Subaccount. If the authentication details are valid, the request will contain a so-called ",(0,r.kt)("strong",{parentName:"li"},"authenticated identity")," for further checks. In combination with an ",(0,r.kt)("a",{parentName:"li",href:"#authorization-policy"},(0,r.kt)("strong",{parentName:"a"},"Authorization Policy")),", this prevents our API from being accessed by malicious, unauthorized attackers."))),(0,r.kt)("li",{parentName:"ul"},"If you want to restrict access to a certain workload, you can make use of ",(0,r.kt)("a",{parentName:"li",href:"#authorization-policy"},(0,r.kt)("strong",{parentName:"a"},"Authorization Policies")),". ",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("a",{parentName:"li",href:"#authorization-policy"},"Authorization Policy")," in our sample scenario checks the authenticated identity (validated by the ",(0,r.kt)("a",{parentName:"li",href:"#request-authentication"},"Request Authentication")," resource) and only grants access to the target ",(0,r.kt)("a",{parentName:"li",href:"#service"},"Service"),", if the details of the identity match a certain value. ")))),(0,r.kt)("p",null,"5) Finally, after all policies have been applied, the request has been authenticated and the correct incoming identity was confirmed, the traffic reaches your workloads through the Istio Sidecar Proxy residing in the same Pod. "),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Important")," "),(0,r.kt)("p",{parentName:"admonition"},"As stated in the beginning - the mesh-internal traffic all along the way (from your Ingress Gateway to the Istio Sidecar Proxy of your workload) will be mTLS encrypted! ")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Egress Traffic")),(0,r.kt)("p",null,"Also outbound communication can be handled by Istio Service Mesh. In our scenario, traffic is leaving the Service Mesh, when we forward requests to SAP API Management where our API Policies are applied. This happens, any time a user tries to call the SaaS API Service and ensures, that traffic policies like Rate Limiting are being enforced by SAP API Management. Once the request has passed through SAP API Management, it will be redirected to Kyma again and can be served by our API Service. "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"The setup details of this SAP API Management integration scenario, are described as part of the Advanced Features.")),(0,r.kt)("p",null,"1) As for any other ingress traffic, the external request targeting our API Service reaches our KymaCluster via the Istio (Ingress) Gateway."),(0,r.kt)("p",null,"2) In this case, a ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," handling the traffic for our API Service workloads, will (in a first iteration) route the request to SAP API Management. "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," decides based on a custom header, whether the request has already passed through SAP API Management or not. ")),(0,r.kt)("p",null,"3) The required SAP API Management host is defined as so-called ",(0,r.kt)("a",{parentName:"p",href:"#service-entry"},"Service Entry")," and can be addressed by Istio (e.g., in ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service"),") like a mesh-internal ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Service"),"."),(0,r.kt)("p",null,"4) A separate ",(0,r.kt)("a",{parentName:"p",href:"#destination-rule"},"Destination Rule")," (specifying how to handle traffic targeting the ",(0,r.kt)("a",{parentName:"p",href:"#service-entry"},"Service Entry"),") allows an exception from the default mesh-internal mTLS communication for the external traffic. "),(0,r.kt)("p",null,"In our simple scenario, for the outbound communication, we are not using a separate Istio (Egress) Gateway. Having substantial outgoing traffic in your service mesh, you might think about setting up a dedicated Istio Egress Gateway. An Egress Gateway is the counterpart of an Istio Ingress Gateway and from a functionality perspective (once again) resembles an ",(0,r.kt)("strong",{parentName:"p"},"Envoy"),' proxy placed "at the edge" of the Service Mesh. '),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Good To Know")),(0,r.kt)("p",null,"There are a few things that you should be aware of, when using Istio in a Kyma context. "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"By default, Istio is using so-called ",(0,r.kt)("strong",{parentName:"p"},"Auto mTLS")," for ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Service")," to ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Service")," communication within the mesh. Therefore, it is not necessary to define ",(0,r.kt)("a",{parentName:"p",href:"#destination-rule"},"Destination Rules")," enabling mutual TLS (",(0,r.kt)("em",{parentName:"p"},"ISTIO_MUTUAL"),") for your workloads. Only if you need to disable mTLS for any of your routing targets (like in our case SAP API Management), you can overwrite respective settings in a ",(0,r.kt)("a",{parentName:"p",href:"#destination-rule"},"Destination Rule"),". "),(0,r.kt)("blockquote",{parentName:"li"},(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Istio-Documentation")," - Istio makes this easy with a feature called \u201cAuto mTLS\u201d. Auto mTLS works by doing exactly that. If TLS settings are not explicitly configured in a DestinationRule, the sidecar will automatically determine if Istio mutual TLS should be sent. This means that without any configuration, all inter-mesh traffic will be mTLS encrypted (",(0,r.kt)("a",{parentName:"p",href:"https://istio.io/latest/docs/ops/configuration/traffic-management/tls-configuration/#auto-mtls"},"see details"),")."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"By default, Kyma has enabled so-called ",(0,r.kt)("strong",{parentName:"p"},"STRICT")," ",(0,r.kt)("a",{parentName:"p",href:"https://istio.io/latest/docs/reference/config/security/peer_authentication/"},"Peer Authentication")," in the ",(0,r.kt)("strong",{parentName:"p"},"istio-system")," namespace. Peer Authentication specifies how or traffic will be tunneled (if required) to your Sidecar Proxies. This setting defined on ",(0,r.kt)("strong",{parentName:"p"},"istio-system")," namespace level, applies the respective Peer Authentication setting for the whole Service Mesh. Consequently, the Istio Sidecar Proxies will only accept mTLS traffic except a different settings has been explicitly defined. "),(0,r.kt)("blockquote",{parentName:"li"},(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Kyma-Documentation")," - In Kyma's default Istio configuration, peer authentication is set to Cluster-wide STRICT mode. This ensures that your workload only accepts mutual TLS traffic where both, client and server certificates, are validated to have all traffic encrypted. This provides each service with a strong identity, with reliable key and certificate management system.")))),(0,r.kt)("h3",{id:"authorization-policy"},"Authorization Policy"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more")," - ",(0,r.kt)("a",{parentName:"p",href:"https://istio.io/latest/docs/reference/config/security/authorization-policy/"},"https://istio.io/latest/docs/reference/config/security/authorization-policy/"))),(0,r.kt)("p",null,"Authorization Policies are required to secure workloads in your Service Mesh based on a variety of rules. In our sample we are using Authorization rules to limit internal communication within the Service Mesh, by allowing access to our workloads only to authenticated so-called principals. Below you can see a sample in which a request to our Backend Service will only be granted access, if it can prove one of the following requirements:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The request has passed through ",(0,r.kt)("a",{parentName:"p",href:"#istio-service-mesh"},"Istio")," Ingress Gateway and tries to call a */-/cds/** path. This requirement is fulfilled by all requests arriving in the Kyma Cluster through the public internet, as the CAP Provisioning or Extensibility endpoints will be directly called from either SAP BTP or developers deploying an extension. ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The request is originating from our Application Router. As we are using mTLS communication within the Cluster, Istio will automatically extract the identity of the source (in this case our Application Router) and place it into the ",(0,r.kt)("em",{parentName:"p"},"source.principal")," property. In case of mTLS communication within the Service Mesh, the principal value is based on the ",(0,r.kt)("a",{parentName:"p",href:"#service-account"},"Service Account")," assigned to origin workload and has the following standardized format (\\<TRUST_DOMAIN",">","/ns/\\<NAMESPACE",">","/sa/\\<SERVICE_ACCOUNT",">",") while ",(0,r.kt)("em",{parentName:"p"},"ns")," means namespace and ",(0,r.kt)("em",{parentName:"p"},"sa")," means ",(0,r.kt)("a",{parentName:"p",href:"#service-account"},"Service Account"),". "))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: security.istio.io/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: susaas-srv\nspec:\n  selector: \n    matchLabels:\n      app.kubernetes.io/name: srv\n  action: ALLOW\n  rules:\n  # External traffic will reach the Service through Istio Ingress Gateway\n  # Only /-/cds/* paths are exposed to direct external traffic\n  - from: \n    - source:\n        principals:\n          - cluster.local/ns/istio-system/sa/istio-ingressgateway-service-account\n    to:\n    - operation:\n        paths: \n          - /-/cds/*\n  # Traffic on all paths can reach the Service through Application Router\n  - from:\n    - source:\n        principals: \n          - cluster.local/ns/default/sa/susaas-router\n")),(0,r.kt)("p",null,"An external request which is trying to reach the API Service after passing through our SAP API Management policies, can be check for an authenticated identity based on the ",(0,r.kt)("em",{parentName:"p"},"requestPrincipal")," property. In the below sample, an Authorization Policy restricts access to the SaaS API workloads to requests that can prove their identity using a JWT token that was issued by ",(0,r.kt)("em",{parentName:"p"},(0,r.kt)("a",{parentName:"em",href:"https://ci-us20.authentication.us20.hana.ondemand.com/oauth/token"},"https://ci-us20.authentication.us20.hana.ondemand.com/oauth/token"))," and contains a subject starting with ",(0,r.kt)("em",{parentName:"p"},"sb-susaas-api-default!"),". In our scenario, this allows us to protect endpoints from being accessed by requestors that are not in possession of valid SAP XSUAA Client Credentials. The respective JWT token is injected by SAP API Management after all traffic policies have been successfully applied. "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"As you can see, for mesh-internal communication between two Sidecar Proxies (using mTLS), we can rely on the ",(0,r.kt)("em",{parentName:"p"},"principal")," property of the source (to securely identify the origin of the request). Additionally, we can check the ",(0,r.kt)("em",{parentName:"p"},"requestPrincipals")," property to restrict access, based on the authenticated identity which a request provides in a valid JWT token of a trusted issuer. ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: security.istio.io/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: susaas-api-apim\nspec:\n  selector:\n    matchLabels:\n      app.kubernetes.io/name: api\n  action: ALLOW\n  rules:\n  - from:\n    # Grant access to requests from Istio Ingress Gateway that can proof a certain requestPrincipal value \n    - source:\n        principals:\n          - cluster.local/ns/istio-system/sa/istio-ingressgateway-service-account\n        requestPrincipals: \n          - https://sap-demo.authentication.us20.hana.ondemand.com/oauth/token/sb-susaas-api-default!*\n")),(0,r.kt)("p",null,"If you enable ",(0,r.kt)("strong",{parentName:"p"},"access strategies")," in your Kyma ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rules")," or you make use of ",(0,r.kt)("strong",{parentName:"p"},"mutators"),", please make sure to also grant access to the ",(0,r.kt)("a",{parentName:"p",href:"#ory"},"Ory")," Oathkeeper Service Account principal. In our scenario this is required for the Application Router ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Service"),", as ",(0,r.kt)("a",{parentName:"p",href:"#ory"},"Ory")," will mutate incoming requests and inject the ",(0,r.kt)("strong",{parentName:"p"},"x-custom-host")," header containing the subdomain of the respective Subscriber Tenant. This allows dynamic definition of custom domains while still being able to uniquely identify a Tenant based on the given TENANT_HOST_PATTERN. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: security.istio.io/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: susaas-router\nspec:\n  selector: \n    matchLabels:\n      app.kubernetes.io/name: router\n  action: ALLOW\n  rules:\n  - from: \n    - source:\n        principals:\n          - cluster.local/ns/istio-system/sa/istio-ingressgateway-service-account\n          - cluster.local/ns/kyma-system/sa/oathkeeper-maester-account\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"To retain Application Router access without the necessity of using a dedicated Subscriber tenant, another default ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rule")," was defined which is bypassing ",(0,r.kt)("a",{parentName:"p",href:"#ory"},"Ory")," and can be used for development or test-purposes. Therefore, also the Istio Ingress Gateway Principal is still part of the Authorization Policy.")),(0,r.kt)("h3",{id:"destination-rule"},"Destination Rule"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more")," - ",(0,r.kt)("a",{parentName:"p",href:"https://istio.io/latest/docs/reference/config/networking/destination-rule/"},"https://istio.io/latest/docs/reference/config/networking/destination-rule/"))),(0,r.kt)("p",null,"Destination Rules are used to define policies for traffic targeting a ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Service")," after routing by ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," has happened. In our sample we are using Destination Rules to enable Session Stickiness for traffic targeting the Application Router Service. As the Application Router is storing client sessions, we need ensure that traffic is always routed to same workload storing the corresponding client session. Therefore, we use a ",(0,r.kt)("strong",{parentName:"p"},"loadBalancer")," Traffic Policy route traffic based on the JSESSIONID cookie of the incoming request."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: susaas-router\nspec:\n  host: susaas-router.default.svc.cluster.local\n  trafficPolicy:\n    loadBalancer:\n      consistentHash:\n        httpCookie:\n          name: JSESSIONID\n          path: /\n          ttl: 0s\n")),(0,r.kt)("p",null,"Another scenario requiring Destination Rules, is the mesh-external communication with SAP API Management. Whenever we reach out to SAP API Management from our Service Mesh, the following Destination Rule ensures that a simple TLS connection is being used for the upstream communication (instead of the default Cluster internal mTLS communication). "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"For communication within the Service Mesh, Istio enforces mTLS communication if not explicitly overridden by a Destination Rule. ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: susaas-apim\nspec:\n  host: sap-demo.prod.apimanagement.eu10.hana.ondemand.com\n  trafficPolicy:\n    portLevelSettings:\n      - port:\n          number: 443\n        tls:\n          mode: SIMPLE\n")),(0,r.kt)("p",null,"Another use-case for using Destination Rules is the Load Balancing between different workload versions using so-called subsets. While not being used in our sample scenario, this allows scenarios like A/B testing by only forwarding a certain percentage of your traffic to latest workload versions. The remaining traffic continuously targets the legacy workload version. ",(0,r.kt)("a",{parentName:"p",href:"https://istio.io/latest/docs/reference/config/networking/destination-rule/#Subset"},"Click here")," for more details."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"Make sure the respective label is added by the ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," to enable subset routing. ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: susaas-sample\nspec:\n  host: susaas-sample.default.svc.cluster.local\n  trafficPolicy:\n    loadBalancer:\n      simple: LEAST_REQUEST\n  subsets:\n  - name: latestfeatures\n    labels:\n      version: v2\n    trafficPolicy:\n      loadBalancer:\n        simple: ROUND_ROBIN\n")),(0,r.kt)("h3",{id:"request-authentication"},"Request Authentication"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more")," - ",(0,r.kt)("a",{parentName:"p",href:"https://istio.io/latest/docs/reference/config/security/request_authentication/"},"https://istio.io/latest/docs/reference/config/security/request_authentication/"))),(0,r.kt)("p",null,"An Istio Request Authentication allows you to check an incoming request for valid authentication details e.g., based on a JWT token in the request header. In our sample scenario, we are using a strategy, which validates the eligibility of a JWT token based on a list of so-called trusted issuers. "),(0,r.kt)("p",null,"This means, whenever a request is able to present a JWT token (in the custom x-jwt-assertion header) which is issued by a trusted issuer (in our case the XSUAA tenant of the Provider Subaccount), the respective authentication details are considered ",(0,r.kt)("strong",{parentName:"p"},"valid"),". Consequently, the respective authentication details will be available for further processing (e.g., the authenticated identity). If the request is not able to provide a valid JWT token, it will not be rejected, but will just simply not contain ",(0,r.kt)("strong",{parentName:"p"},"valid")," authentication information (like the authenticated identity). "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"Request Authentication definitions are especially useful in combination with so-callled ",(0,r.kt)("a",{parentName:"p",href:"#authorization-policy"},"Authorization Policies"),". Based on the extracted authentication details, those policies define, whether or not a request is ultimately allowed to reach a service. ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: security.istio.io/v1beta1\nkind: RequestAuthentication\nmetadata:\n  name: susaas-api\nspec:\n  selector:\n    matchLabels:\n      app.kubernetes.io/name: api\n  # List of authentication rules applied to requests targeting the workload \n  jwtRules:\n    # List of trusted JWT token issuers\n    - issuer: https://sap-demo.authentication.us20.hana.ondemand.com/oauth/token\n      jwksUri: https://sap-demo.authentication.us20.hana.ondemand.com/token_keys\n      # Custom header field of JWT token is not in "Authorization"\n      fromHeaders:\n        - name: x-jwt-assertion\n')),(0,r.kt)("p",null,"To identify the issuer and jwksUri details in case of XSUAA usage, you can follow the below format. Please make sure to provide the Subdomain and Region of your SAP BTP Provider Subaccount. "),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"issuer")," - https://\\<SUBDOMAIN",">",".authentication.\\<REGION",">",".hana.ondemand.com/oauth/token",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"jwksUri")," - https://\\<SUBDOMAIN",">",".authentication.\\<REGION",">",".hana.ondemand.com/token_keys"),(0,r.kt)("h3",{id:"service-entry"},"Service Entry"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more")," - ",(0,r.kt)("a",{parentName:"p",href:"https://istio.io/latest/docs/reference/config/networking/service-entry/"},"https://istio.io/latest/docs/reference/config/networking/service-entry/"))),(0,r.kt)("p",null,"To enable communication from your Service Mesh to external services like SAP API Management, you need to define a so called Istio ",(0,r.kt)("strong",{parentName:"p"},"Service Entry"),". Besides the host of your external service, this resource type defines ports, protocols and how the host will be resolved like in our case using a DNS-based resolution. "),(0,r.kt)("p",null,"Once the Service Entry is defined, it will be available on Istio service registry then it can be used in your Service Mesh. In our sample scenario, it is part of a ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," routing definition, which you can find in a subsequent part of this chapter (",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"see here"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: networking.istio.io/v1alpha3\nkind: ServiceEntry\nmetadata:\n  name: susaas-apim\nspec:\n  hosts: \n    - sap-demo.prod.apimanagement.us20.hana.ondemand.com\n  location: MESH_EXTERNAL\n  ports:\n  - number: 443\n    name: https\n    protocol: TLS\n  resolution: DNS\n")),(0,r.kt)("h3",{id:"sidecar"},"Sidecar"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"https://istio.io/latest/docs/reference/config/networking/sidecar/"},"https://istio.io/latest/docs/reference/config/networking/sidecar/"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"https://blogs.sap.com/2022/05/02/optimising-istio-sidecar-usage-in-kyma-runtime/"},"https://blogs.sap.com/2022/05/02/optimising-istio-sidecar-usage-in-kyma-runtime/"))),(0,r.kt)("p",null,"By default, Istio enables communication between all ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Services")," in the mesh, storing required details in each Sidecar Proxy. While not extremely relevant in a small sample scenario, with a growing number of ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Services")," in your Service Mesh, this will become a huge overhead, as usually a micro service only needs to communicate with a few other microservices but not with the full mesh. To optimize the communication between your ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Services")," (and the required configurations stored in your Sidecar Proxies), you can define so-called Sidecars resources."),(0,r.kt)("p",null,"Those Sidecars resources allow you to specify which ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Services")," a certain workload needs to reach within the mesh. In the below sample, we tell the Istio, that the Sidecar Proxy of our Application Router only needs to reach out to ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Services")," in the same (./*) and in the istio-system namespace. So even if there are thousands of ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Services")," in your Mesh one day, only the required configurations for a few ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Services")," would be fetched from the Istio Control Plane and stored in the Sidecar Proxy. This will reduce CPU, memory and disk usage in the Istio Control Plane as well as the Sidecar Proxies. "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"While this is not part of our sample scenario, even Ingress traffic settings could be further specified in this context. Check the official documentation to learn more.  ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: networking.istio.io/v1beta1\nkind: Sidecar\nmetadata:\n  name: susaas-router\nspec:\n  # Workload selector which this Sidecar configuration is applied to \n  workloadSelector: \n    labels:\n      app.kubernetes.io/name: router\n  # Only fetches and stores Istio configuration for certain hosts\n  # In this case for egress traffic in the same and the istio-system namespace\n  egress:\n    - hosts:\n      - ./*\n      - istio-system/*\n")),(0,r.kt)("h3",{id:"virtual-service"},"Virtual Service"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more")," - ",(0,r.kt)("a",{parentName:"p",href:"https://istio.io/latest/docs/reference/config/networking/virtual-service/"},"https://istio.io/latest/docs/reference/config/networking/virtual-service/"))),(0,r.kt)("p",null,"Virtual Services allow you to route traffic to the ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Services")," associated with your workloads based on various conditions. In our sample scenario, the majority of Virtual Services define traffic rules based on the initial host which the incoming request is targeting. In the below example, whenever a request for the ",(0,r.kt)("strong",{parentName:"p"},"susaas-router-default.sap-demo.com")," host arrives through Istio Ingress Gateway, we need to instruct Istio to which ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Service")," this traffic has to be routed. Obviously, in this case the traffic is intended for our Application Router workload. So we can simply provide the Cluster IP ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Service")," details of our Application Router workload in the destination details of the route. "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"In this example, a custom domain is being used. In a default setup, the default Kyma ",(0,r.kt)("strong",{parentName:"p"},"kyma-system/kyma-gateway")," Gateway as well as the default Cluster domain would be used (e.g., susaas-router-default.a1b2c3d4.kyma.ondemand.com).")),(0,r.kt)("p",null,"The Virtual Services required for this sample scenario, are (except for one exception) automatically created and manged by so-called Kyma ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rules"),". This means, whenever you create or update an ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rule"),", a corresponding Virtual Service is created or updated. While this reduced flexibility (as ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rules")," only offer a subset of the Virtual Service features) it simplifies the majority of scenarios, which are just about a simple exposure of workloads. "),(0,r.kt)("p",null,"In the below sample, the Virtual Service (created by the corresponding and equally named ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rule"),") will match any request arriving through the Istio Gateway name ",(0,r.kt)("strong",{parentName:"p"},"sap-demo-gateway"),", targeting the ",(0,r.kt)("strong",{parentName:"p"},"susaas-router-default.sap-demo.com")," host. Any matching request will be routed to the Cluster IP ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Service")," of our Application Router workload, while attaching an ",(0,r.kt)("em",{parentName:"p"},"x-forwarded-host")," header, which is retaining the initial target host. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: susaas-router\nspec:\n  # Handle requests of the sap-demo-gateway Gateway\n  gateways:\n    - demo-dns/sap-demo-gateway\n  # Handle requests targeting the susaas-router-default host\n  hosts:\n    - susaas-router-default.sap-demo.com\n  http:\n    # Match requests for all paths \n    - match:\n      - uri:\n          regex: /.*\n      # Add x-forwarded-host header to retain initial target host\n      headers:\n        request:\n          set:\n            x-forwarded-host: susaas-router-default.sap-demo.com\n      # Route to Cluster IP Service of Application Router\n      route:\n        - destination:\n            host: susaas-router.default.svc.cluster.local\n            port:\n              number: 5000\n")),(0,r.kt)("p",null,"As already described as part of the ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rule")," documentation, the ",(0,r.kt)("strong",{parentName:"p"},"Virtual Services")," created for the Subscriber Tenants manifest in slightly different results. As we require an additional ",(0,r.kt)("strong",{parentName:"p"},"x-custom-host")," header to uniquely identify the subdomain of a Subscriber tenant, the Virtual Service will route traffic through ",(0,r.kt)("a",{parentName:"p",href:"#ory"},"Ory")," Oathkeeper. Based on our ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rule")," definition, ",(0,r.kt)("a",{parentName:"p",href:"#ory"},"Ory")," will add the respective header.   "),(0,r.kt)("p",null,"Below you can find a sample for such a generated Virtual Service instance serving a Subscriber Tenant and routing traffic through ",(0,r.kt)("a",{parentName:"p",href:"#ory"},"Ory")," for required header mutation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: susaas-tenant-e1771-25rzp\nspec:\n  gateways: ["demo-dns/sap-demo-gateway"]\n  hosts: ["subscriber.sap-demo.com"]\n  http:\n    - headers:\n        # Original target host is retained in header\n        request:\n          set:\n            x-forwarded-host: subscriber.sap-demo.com\n      match:\n        - uri:\n            regex: /.*\n      route:\n        # Route traffic to the Cluster IP Service of Ory Oathkeeper\n        # x-custom-host header added by Ory Oathkeeper\n        - destination:\n            host: ory-oathkeeper-proxy.kyma-system.svc.cluster.local\n            port:\n              number: 4455\n          weight: 100\n')),(0,r.kt)("p",null,"The integration of SAP API Management is the only exception for which a dedicated Virtual Service instance is defined in our sample application Helm charts. In this case, any request targeting the API Service host (e.g., susaas-api-default.sap-demo.com) is checked for a custom header named ",(0,r.kt)("em",{parentName:"p"},"x-jwt-assertion"),". "),(0,r.kt)("p",null,"This custom header is added by SAP API Management after validating associated API Policies (e.g., Rate Limiting). Only requests that have passed through SAP API Management and contain this custom header, will match the second HTTP match pattern and are consequently routed to the Cluster IP ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Service")," of the API Service workload. In any other case, requests (missing the custom header) are routed to SAP API Management (defined as mesh external ",(0,r.kt)("a",{parentName:"p",href:"#service-entry"},"Service Entry"),"). "),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Important")," "),(0,r.kt)("p",{parentName:"admonition"},"As of today, ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rules")," do not allow multiple routes for the same host, therefore a dedicated Virtual Service is necessary to provide this routing requirements. ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: susaas-api\nspec:\n  # Handle requests of the sap-demo-gateway Gateway\n  gateways: \n    - demo-dns/sap-demo-gateway\n  # Handle requests targeting the susaas-api-default host\n  hosts: \n    - susaas-api-default.sap-demo.com\n  http:\n    # Match requests containing the custom x-jwt-assertion header\n    - match:\n        - headers:\n            x-jwt-assertion: {}\n      # Route requests to the Cluster IP Service of the SaaS API Service workload\n      route:\n      - destination:\n          host: susaas-api.default.svc.cluster.local\n          port:\n            number: 5000\n    # Match requests without the custom x-jwt-assertion header\n    - match:\n        - withoutHeaders:\n            x-jwt-assertion: {}\n      # Rewrite the URL and add the API Proxy path of SAP API Management\n      rewrite:\n        uri: /kyma-api-susaas/\n        authority: sapdemo.prod.apimanagement.us20.hana.ondemand.com\n      # Route request to SAP API Management based on Istio Service Entry \n      route:\n      - destination:\n          host: sapdemo.prod.apimanagement.us20.hana.ondemand.com\n          port:\n            number: 443\n")),(0,r.kt)("p",null,"To learn more about the integration of SAP API Management, please read the respective chapter in the Advanced Features (",(0,r.kt)("a",{parentName:"p",href:"/PAA/@navyakhurana-arch-val-demo/project-panel/advanced/integrate-sap-api-management/"},"click here"),")."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Cluster Internal Routing")),(0,r.kt)("p",null,"The sample scenario is not leveraging ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," to apply mesh-internal traffic routing rules. So, whenever the Application Router is sending requests to our Backend Service, it will not use any ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," rules to do so. Instead, the traffic will be directly send to the respective Cluster IP ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Service")," of the workload. "),(0,r.kt)("p",null,"In case you want to use ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Services")," also for mesh-internal routing, check the below sample in which an additional Gateway and Host is added to enable mesh-internal routing. In this example (which probably doesn't make any sense from a functionality perspective), the external traffic is send to the subset v1 while internal traffic is routed to a corresponding subset v2. This subset label can now be used to e.g., apply further load-balancing policies in subsequent ",(0,r.kt)("a",{parentName:"p",href:"#destination-rule"},"Destination Rules"),". "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: susaas-router\nspec:\n  gateways: \n    - demo-dns/sap-demo-gateway\n    - mesh # Enables Virtual Service for mesh internal usage\n  hosts: \n    - susaas-router-default.sap-demo.com\n    - susaas-router.default.svc.cluster.local \n  http:\n    # HTTP route mapping based on Gateway\n    - match:\n        - gateways:\n            - demo-dns/sap-demo-gateway\n      route:\n        - destination:\n            host: susaas-router.default.svc.cluster.local\n            subset: v1\n    - match:\n        - gateways:\n            - mesh\n      route:\n        - destination:\n            host: susaas-router.default.svc.cluster.local\n            subset: v2\n")),(0,r.kt)("p",null,"That is it for the Istio related parts of the documentation. Let's go on with the remaining Kubernetes and Kyma resources being used by our sample application."),(0,r.kt)("h2",{id:"job"},"Job"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more")," - ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/workloads/controllers/job/"},"https://kubernetes.io/docs/concepts/workloads/controllers/job/"))),(0,r.kt)("p",null,"Jobs are a convenient way to run one-time workloads in a Kubernetes Cluster. A Job ends, once the associated Pod(s) terminates successfully. In our sample, we are using Jobs for two requirements. "),(0,r.kt)("p",null,"#1 - The deployment of our Shared Database Model to an SAP HANA Cloud HDI Database Container "),(0,r.kt)("p",null,"#2 - The deployment of our SAPUI5 components to an HTML5 Application Repository instance"),(0,r.kt)("p",null,"Both deployments are one-time actions which only need to be executed if there are changes in the data model or any of the UI5 applications. Once the changes are successfully deployed to the respective SAP BTP ",(0,r.kt)("a",{parentName:"p",href:"#service-instance"},"Service Instances"),", the associated Pods can be terminated and the Job will be deleted. "),(0,r.kt)("p",null,"Below you can see the Job which is deploying our SAPUI5 Applications to a HTML5 Application Repository bound to the workload. Similar to a regular ",(0,r.kt)("a",{parentName:"p",href:"#deployment"},"Deployment")," definition, the Job will spin up a new Pod based on the configuration provided. Once the process in the container signals a successful completion of the assigned tasks (e.g., a successful deployment of the latest UI5 apps to the HTML5 Application Repository), the Pod will successfully terminate and the Job will be removed from the Cluster. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: susaas-html5-apps-deployer\nspec:\n  # Number of retries of a Job fails \n  backoffLimit: 4\n  template:\n    # Istio Sidecar Injection is not required for this Pod and can be disabled\n    metadata:\n      labels:\n        sidecar.istio.io/inject: "false"\n    spec:\n      restartPolicy: Never\n      # Volumes required by the workload incl. SAP BTP Service Bindings\n      volumes:\n        - name: html5-apps-repo-secret\n          secret:\n            secretName: "susaas-html5-apps-deployer-html5-apps-repo"\n      # Containers to be placed into the Pod (e.g., HTML5 Apps Deployer)\n      containers:\n        - name: html5-deployer\n          image: sapse/susaas-html5-deployer:latest\n          imagePullPolicy: Always\n          volumeMounts:\n            - name: html5-apps-repo-secret\n              mountPath: /bindings/html5-apps-repo\n              readOnly: true\n          resources:\n            limits:\n              cpu: 500m\n              memory: 500M\n            requests:\n              cpu: 300m\n              memory: 500M\n          # Environment variables\n          env:\n            - name: SERVICE_BINDING_ROOT\n              value: /bindings\n              # Will ensure the process exits after upload - process.exit()\n              # Signals successful completion of Job to Kubernetes\n            - name: EXIT_PROCESS_AFTER_UPLOAD\n              value: "true"\n            - name: ASYNC_UPLOAD\n              value: "true"\n            - name: PORT\n              value: "5000"\n')),(0,r.kt)("p",null,"The deletion of Jobs after successful termination is triggered by respective Helm Hooks. The below sample triggers a deletion of the associated Kubernetes artifact (in our case the Job), before a new Job artifact is created in the Cluster and after the Job successfully terminated. This will ensure that you are not ending up with dozens of orphaned jobs when upgrading your Helm installation several times. "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"In case you would like to retain your Jobs, you need to modify or remove the respective hook-delete-policy in the Helm templates. ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'annotations:\n  "helm.sh/hook": "post-install,post-upgrade"\n  "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded\n')),(0,r.kt)("h2",{id:"network-policy"},"Network Policy"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/services-networking/network-policies/"},"https://kubernetes.io/docs/concepts/services-networking/network-policies/"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"https://istio.io/latest/blog/2017/0.1-using-network-policy/"},"https://istio.io/latest/blog/2017/0.1-using-network-policy/"))),(0,r.kt)("p",null,"Network Policies provide you additional security features on the L3 and L4 layer (Network/Transport), while Istio ",(0,r.kt)("a",{parentName:"p",href:"#authorization-policy"},"Authorization Policies")," offer similar features on the Application/Service layer (L7). Therefore, it is recommended to use both resources to protect your workloads in the best possible way with ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Zero_trust_security_model"},"zero-trust")," mindset."),(0,r.kt)("p",null,"In case there is any issue with the Istio images used by your Sidecar Proxies and you are facing a security breach on application level (L7), your workloads are still protected from access by workloads not listed in the Network Policy. ",(0,r.kt)("a",{parentName:"p",href:"#authorization-policy"},"Authorization Policies")," are applied at at Pod level, whereas Network Policies are enforced on a Node level. "),(0,r.kt)("p",null,"In the below sample, the Network Policy ensures, that ",(0,r.kt)("strong",{parentName:"p"},"network")," traffic targeting the API Service Broker is only granted to workloads of our ",(0,r.kt)("a",{parentName:"p",href:"#istio-service-mesh"},"Istio")," Ingress Gateway. This protects our Service Broker from being maliciously accessed by any other workload in the Cluster. Network Policies are especially useful in scenarios where Istio Sidecar injection is disabled. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: susaas-broker\nspec:\n  policyTypes:\n    - Ingress\n  podSelector:\n    matchLabels:\n      app.kubernetes.io/name: broker\n      app.kubernetes.io/instance: susaas\n  ingress:\n    - from:\n        - podSelector:\n            matchLabels:\n              app: istio-ingressgateway\n          namespaceSelector:\n            matchLabels:\n              name: istio-system\n")),(0,r.kt)("p",null,"Let's check another example. Besides access from the Istio Ingress Gateway, the following Network Policy of our Backend Service also permits access from the Application Router workload. This is required to allow a communication from our Application Router to the Backend Services after successful authentication and determination of the Tenant identifier. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: susaas-srv\nspec:\n  policyTypes:\n    - Ingress\n  podSelector:\n    matchLabels:\n      app.kubernetes.io/name: srv\n      app.kubernetes.io/instance: susaas\n  ingress:\n    - from:\n        - podSelector:\n            matchLabels:\n              app.kubernetes.io/name: router\n              app.kubernetes.io/instance: susaas\n          namespaceSelector:\n            matchLabels:\n              name: default\n        - podSelector:\n            matchLabels:\n              app: istio-ingressgateway\n          namespaceSelector:\n            matchLabels:\n              name: istio-system\n")),(0,r.kt)("p",null,"If you enabled ",(0,r.kt)("strong",{parentName:"p"},"access strategies")," in your Kyma ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rules")," or you make use of ",(0,r.kt)("strong",{parentName:"p"},"mutators"),", please also grant access to the ",(0,r.kt)("a",{parentName:"p",href:"#ory"},"Ory")," Oathkeeper workloads in addition to the ",(0,r.kt)("a",{parentName:"p",href:"#istio-service-mesh"},"Istio")," Ingress Gateway workloads. In our scenario, this is required for the Application Router workloads, as ",(0,r.kt)("a",{parentName:"p",href:"#ory"},"Ory")," is responsible for the injection of the ",(0,r.kt)("strong",{parentName:"p"},"x-custom-host")," header and traffic is not directly routed from Istio Ingress Gateway to our Services. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: susaas-broker\nspec:\n  policyTypes:\n    - Ingress\n  podSelector:\n    matchLabels:\n      app.kubernetes.io/name: broker\n      app.kubernetes.io/instance: susaas\n  ingress:\n    - from:\n        - podSelector:\n            matchLabels:\n              app: istio-ingressgateway\n          namespaceSelector:\n            matchLabels:\n              name: istio-system\n        - podSelector:\n            matchLabels:\n              app.kubernetes.io/name: oathkeeper\n              app.kubernetes.io/instance: ory\n          namespaceSelector:\n            matchLabels:\n              name: kyma-system\n")),(0,r.kt)("p",null,"Network Policies can also be used to prevent any communication from your Cluster trying to bypass a potential ",(0,r.kt)("strong",{parentName:"p"},"Istio Egress Gateway"),". This can be facilitated by permitting cluster-wide egress traffic from respective Istio Egress Gateway workloads only. "),(0,r.kt)("h2",{id:"ory"},"Ory"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"https://www.ory.sh/docs/welcome"},"https://www.ory.sh/docs/welcome"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"https://kyma-project.io/docs/kyma/latest/05-technical-reference/00-custom-resources/apix-01-apirule"},"https://kyma-project.io/docs/kyma/latest/05-technical-reference/00-custom-resources/apix-01-apirule"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"https://kyma-project.io/blog/2019/7/31/kyma-collaboration-with-ory"},"https://kyma-project.io/blog/2019/7/31/kyma-collaboration-with-ory"))),(0,r.kt)("p",null,"Although, not extensively used in our sample scenario, multiple ",(0,r.kt)("a",{parentName:"p",href:"https://www.ory.sh/"},"Ory")," components are a pre-configured part of your Kyma Cluster and provide additional security features to prevent unauthorized access to your workloads. "),(0,r.kt)("p",null,"This includes an OAuth Server named ",(0,r.kt)("a",{parentName:"p",href:"https://www.ory.sh/docs/hydra"},"Ory Hydra"),", mutator features allowing us to inject custom headers, as well as ",(0,r.kt)("strong",{parentName:"p"},"access strategies")," which can be enabled in your Kyma ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rules")," and are handled by the so-called ",(0,r.kt)("a",{parentName:"p",href:"https://www.ory.sh/docs/oathkeeper"},"Ory Oathkeeper"),". Ory Oathkeeper's primary task is the authentication and authorization of incoming HTTP requests."),(0,r.kt)("p",null,"Below you can find an example of an ",(0,r.kt)("strong",{parentName:"p"},"hypothetical")," ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rule"),", which makes use of a JWT-based access strategy, validating whether the JWT token of a request is issued by a trusted XSUAA tenant."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: gateway.kyma-project.io/v1beta1\nkind: APIRule\nmetadata:\n  name: susaas-api\nspec:\n  # The API Rule will handle requests arriving for this Istio Gateway\n  gateway: demo-dns/sap-demo-gateway\n  # The API Rule will handle all requests arriving for this host\n  host: susaas-api-default.sap-demo.com\n  rules:\n    # Traffic on all paths will be routed to the Cluster IP service\n    - methods:\n        - GET\n        - POST\n        - PUT\n        - DELETE\n        - HEAD\n      path: /.*\n      # Access strategies defined here will result in Ory Oathkeeper Rules\n      accessStrategies:\n        - handler: jwt\n          config:\n            jwks_urls:\n              - https://sap-demo.authentication.us20.hana.ondemand.com/token_keys\n            trusted_issuers:\n              - https://sap-demo.authentication.us20.hana.ondemand.com/oauth/token\n  # Cluster IP Service to which the traffic is routed\n  service:\n    name: susaas-api\n    port: 5000\n")),(0,r.kt)("p",null,"Enabling access strategies in ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rules")," (being validated Ory Oathkeeper), will also update the auto-generated ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Services"),". In this case, the ",(0,r.kt)("a",{parentName:"p",href:"#virtual-service"},"Virtual Service")," generated by the Kyma ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rule"),", is not directly routing requests to the corresponding Cluster IP ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Service")," anymore, but initially routes traffic to the Ory Oathkeeper ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Service")," workloads. Ory takes care of validating the provided access strategy details, before redirecting the traffic to the intended target ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Service"),". "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: susaas-api\nspec:\n  gateways:\n    - demo-dns/sap-demo-gateway\n  hosts:\n    - susaas-api-default.sap-demo.com\n  http:\n    - match:\n        - uri:\n            regex: /.*\n      ...\n      # Route to Ory Oathkeeper instead of the API Service\n      headers:\n        # Original host is retained in header\n        request:\n          set:\n            x-forwarded-host: susaas-api-default.sap-demo.com\n      route:\n        # Virtual Service routes traffic to Ory Oathkeeper Service\n        - destination:\n            host: ory-oathkeeper-proxy.kyma-system.svc.cluster.local\n            port:\n              number: 4455\n")),(0,r.kt)("p",null,"Below you can see a simple definition of a custom so-called ",(0,r.kt)("strong",{parentName:"p"},"Ory Rule")," (which is automatically created in a similar fashion when deploying the above ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rule"),"). In this sample, the Ory Rule ensures that requests targeting the ",(0,r.kt)("strong",{parentName:"p"},"susaas-api-default.sap-demo.com")," host, have to provide a valid JWT token, issued by a trusted XSUAA tenant. Otherwise, the request will not be granted access to the so-called upstream target (Cluster IP ",(0,r.kt)("a",{parentName:"p",href:"#service"},"Service")," of our API Service). "),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Important")," "),(0,r.kt)("p",{parentName:"admonition"},"The Ory components (first of all the Ory Hydra OAuth Server) will be removed in upcoming Kyma releases. While the majority of existing features provided by Kyma ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rules")," will be replaced (e.g., by corresponding ",(0,r.kt)("a",{parentName:"p",href:"#istio-service-mesh"},"Istio")," features), we strongly recommend not to use ",(0,r.kt)("strong",{parentName:"p"},"native Ory objects")," anymore. The Ory-related details are only mentioned to give you an idea of what is happening under the hood, when creating a new ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rule")," including access strategies. ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: oathkeeper.ory.sh/v1alpha1\nkind: Rule\nmetadata:\n    name: susaas-api\nspec:\n  authenticators:\n    - handler: jwt\n      config: \n        jwks_urls:\n          - https://sap-demo.authentication.us20.hana.ondemand.com/token_keys\n        trusted_issuers:\n          - https://sap-demo.authentication.us20.hana.ondemand.com/oauth/token\n  authorizer:\n    handler: allow\n  match:\n    methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD"]\n    url: <http|https>://susaas-api-default.sap-demo.com/<.*>\n  upstream:\n    url: http://susaas-api.default.svc.cluster.local:5000\n')),(0,r.kt)("p",null,"Another ",(0,r.kt)("strong",{parentName:"p"},"Ory")," feature set which is actively being used in the ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rules")," of our Subscriber tenants, are so-called ",(0,r.kt)("a",{parentName:"p",href:"https://www.ory.sh/docs/oathkeeper/pipeline/mutator#header"},"mutators"),". In our scenario, mutators facilitate the injection of the ",(0,r.kt)("strong",{parentName:"p"},"x-custom-host")," header required for Tenant identification. Check out the sample below to find a respective mutator definition. "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"In the future this might be replaced by an Istio-based approach setting the custom header. ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: gateway.kyma-project.io/v1beta1\nkind: APIRule\nmetadata:\n  name: susaas-tenant-e1771\nspec:\n  # Handle requests arriving for this Istio Gateway\n  gateway: demo-dns/sap-demo-gateway\n  # Handle requests for this custom Subscriber subdomain\n  host: subscriber.sap-demo.com\n  rules:\n    - methods:\n        - GET\n        - POST\n        - PUT\n        - DELETE\n        - HEAD\n      path: /.*\n      accessStrategies:\n        - handler: noop\n      # Mutator definition injecting a custom header \n      mutators:\n        - config:\n            headers:\n              x-custom-host: subscriber-a1b2c3-susaas-router-default.sap-demo.com\n          handler: header\n      path: /.*\n  # Cluster IP Service the traffic is routed after passing Ory Oathkeeper\n  service:\n    name: susaas-router\n    port: 5000\n")),(0,r.kt)("h2",{id:"pod-autoscaler"},"Pod Autoscaler"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more")," - ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/"},"https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/"))),(0,r.kt)("p",null,"The Horizontal Pod Autoscaler (as the name suggests) horizontally scales your workloads based on defined metrics like CPU utilization. Autoscalers can be applied to Replication Controllers like ",(0,r.kt)("a",{parentName:"p",href:"#deployment"},"Deployments")," or Replica Sets. In our example the Horizontal Pod Autoscalers are assigned to the ",(0,r.kt)("a",{parentName:"p",href:"#deployment"},"Deployments")," of our sample application and provide a basic scaling example, based on the CPU consumption of the workloads. "),(0,r.kt)("p",null,"The following Autoscaler definition ensures, that at least one Pod of our API Service workload is constantly running in the Cluster. Furthermore, it will automatically create up to three pods, in case the average CPU utilization across the existing API Service workloads reaches 80 percent. "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"In simple sample scenarios, a Horizontal Pod Autoscaler is probably not required but becomes highly relevant with an increasing workload! Please be aware, that ",(0,r.kt)("strong",{parentName:"p"},"high-availability")," scenarios cannot be achieved with a minReplica setting of 1. At least two Pods (ideally on different Nodes) have to be available in this case.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: susaas-api\nspec:\n  # Set minReplicas value > 2 if High Availability is required\n  minReplicas: 1\n  maxReplicas: 3\n  # HPAs can be applied to Replication Controllers\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: susaas-api\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 80\n")),(0,r.kt)("h2",{id:"pod-disruption-budget"},"Pod Disruption Budget"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/tasks/run-application/configure-pdb/"},"https://kubernetes.io/docs/tasks/run-application/configure-pdb/"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/workloads/pods/disruptions/#pod-disruption-budgets"},"https://kubernetes.io/docs/concepts/workloads/pods/disruptions/#pod-disruption-budgets"))),(0,r.kt)("p",null,"Pod Disruption Budgets are - like Horizontal ",(0,r.kt)("a",{parentName:"p",href:"#pod-autoscaler"},"Pod Autoscalers")," - not extremely relevant in our small sample scenario. Pod Disruption Budgets are required for so called ",(0,r.kt)("strong",{parentName:"p"},"voluntary disruptions"),", for example in case an administrator is planning to take down a Node (e.g., for updates). In these scenarios, the Pod Disruption Budget ensures, that certain availability conditions are fulfilled, before a respective disruption can take place. "),(0,r.kt)("p",null,"In the following sample, the Pod Disruption Budget ensures, that at least two Pods of our Service Broker workload are still available across the remaining Nodes of your Cluster, in case of voluntary disruptions. While an Horizontal ",(0,r.kt)("a",{parentName:"p",href:"#pod-autoscaler"},"Pod Autoscaler")," will step in and spin up new Pods (in case you are taking down a Node with a certain number of Pods), this scaling process will take some time until the new Pods are available. Using a Pod Disruption Budget, your Administrator will not be able to take down a Node, if the remaining Nodes do not provide the minimal number of required Pods for the associated workload. "),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Important")," "),(0,r.kt)("p",{parentName:"admonition"},"The Pod Disruption Budgets does not cover unplanned disruptions like power-outages. In this case, you might face situations in which the minimum number of Pods in your Cluster is temporarily lower than required, until your ",(0,r.kt)("a",{parentName:"p",href:"#deployment"},"Deployment")," or Autoscaler spins up new pods in the remaining Nodes.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: policy/v1\nkind: PodDisruptionBudget\nmetadata:\n  name: susaas-broker\nspec:\n  minAvailable: 2\n  selector:\n    matchLabels:\n      app.kubernetes.io/name: broker\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"A Pod Disruption Budget with a minAvailable value of 1 and a corresponding replica/minReplica (Deployment/Autoscaler) of 1 will not guarantee high availability. Only if at least 2 Pods are running on different Nodes in your Cluster, a minAvailable value of 1 will ensure high availability in case of voluntary disruptions. In case of 1-1 scenarios, the a Pod will only be instantiated, once the existing Pod successfully terminated. ")),(0,r.kt)("h2",{id:"role-binding"},"Role Binding"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more")," - ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/reference/access-authn-authz/rbac/#rolebinding-and-clusterrolebinding"},"https://kubernetes.io/docs/reference/access-authn-authz/rbac/#rolebinding-and-clusterrolebinding"))),(0,r.kt)("p",null,"A Role Binding allows you to assign existing or custom ",(0,r.kt)("a",{parentName:"p",href:"#cluster-role"},"Cluster Roles")," to ",(0,r.kt)("a",{parentName:"p",href:"#service-account"},"Service Accounts"),". In our sample scenario, this is used to provide the ",(0,r.kt)("a",{parentName:"p",href:"#service-account"},"Service Account")," of our Backend Service the required permissions to create ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rules")," at runtime. The respective permissions are defined in a corresponding ",(0,r.kt)("a",{parentName:"p",href:"#cluster-role"},"Cluster Role"),". "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: susaas-srv\n# Subject to assign the Cluster role to (e.g., Service Account)\nsubjects:\n  - kind: ServiceAccount\n    name: susaas-srv\n    namespace: susaas\n# Cluster role which is supposed to be assigned to subject\nroleRef:\n  name: susaas-srv\n  kind: ClusterRole\n  apiGroup: rbac.authorization.k8s.io\n")),(0,r.kt)("h2",{id:"secret"},"Secret"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more")," - ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/reference/access-authn-authz/rbac/#role-and-clusterrole"},"https://kubernetes.io/docs/reference/access-authn-authz/rbac/#role-and-clusterrole"))),(0,r.kt)("p",null,"Kubernetes Secrets allow you to store secret values like passwords or any other kind of sensitive information in your Cluster. Secrets can be referenced in your workload definitions, so that for example credential values can be securely consumed as environment variables at runtime. "),(0,r.kt)("p",null,"In our scenario Secrets are being used in two different facets. The following sample covers the most common Secret use-case, storing custom credentials, like the unique Broker Password and User in our scenario. The respective Secret can be conveniently referenced as part of the ",(0,r.kt)("a",{parentName:"p",href:"#deployment"},"Deployment")," container definition and added as an environment variable. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: v1\nkind: Secret\nmetadata:\n  name: susaas-broker\ntype: Opaque\ndata:\n  BROKER_USER : "YnJva2VyLXVzZXI="\n  BROKER_PASSWORD : "a2RweTRhZ3oxSCV0ExckkzeDN0VXU="\n  BROKER_HASH : "c2hhMjU2OlRYaFl"\n')),(0,r.kt)("p",null,"Below you can see, how to reference this Secret from within your container definition. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: susaas-broker\nspec:\n  selector:\n    matchLabels:\n      app.kubernetes.io/name: broker\n  template:\n    metadata:\n      labels:\n        app.kubernetes.io/name: broker\n    spec:\n      containers:\n      - image: sapse/susaas-broker:latest\n        name: broker\n        envFrom:\n        - secretRef:\n            name: susaas-broker\n")),(0,r.kt)("p",null,"The second important scenario for Secret usage is the SAP BTP ",(0,r.kt)("a",{parentName:"p",href:"#service-binding"},"Service Binding"),". Whenever a SAP BTP ",(0,r.kt)("a",{parentName:"p",href:"#service-binding"},"Service Binding")," is required by our Kyma workloads, the respective Kyma ",(0,r.kt)("a",{parentName:"p",href:"#service-binding"},"Service Binding")," resource will automatically generate a Secret, which contains the Client Credentials or X.509 keys. "),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more")," - ",(0,r.kt)("a",{parentName:"p",href:"https://blogs.sap.com/2022/07/12/the-new-way-to-consume-service-bindings-on-kyma-runtime/"},"https://blogs.sap.com/2022/07/12/the-new-way-to-consume-service-bindings-on-kyma-runtime/"))),(0,r.kt)("p",null,'These "Service Binding" Secrets are then mounted to the container file systems using the ',(0,r.kt)("strong",{parentName:"p"},"bindings")," path. This makes the SAP BTP ",(0,r.kt)("a",{parentName:"p",href:"#service-binding"},"Service Binding")," credentials available to workloads and frameworks like CAP, being able to consume them at runtime by using the @sap/xsenv package."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"kind: Secret\napiVersion: v1\nmetadata:\n  name: susaas-broker-xsuaa-api\ndata:\n  apiurl: https://api.authentication.us20.hana.ondemand.com\n  clientid: sb-susaas-api!b8342\n  clientsecret: 53e9f606-...-bb44-898903\n  credential-type: binding-secret\n  ...\ntype: Opaque\n")),(0,r.kt)("p",null,"Below, you can find the ",(0,r.kt)("a",{parentName:"p",href:"#deployment"},"Deployment")," referencing the generated SAP BTP Service Binding Secret. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: susaas-broker\nspec:\n  selector:\n    matchLabels:\n      app.kubernetes.io/name: broker\n  template:\n    metadata:\n      labels:\n        app.kubernetes.io/name: broker\n    spec:\n      containers:\n      - image: sapse/susaas-broker:latest\n        name: broker\n        env:\n        # File system path where you mount your Service Binding Secrets\n        - name: SERVICE_BINDING_ROOT\n          value: /bindings\n        # Volumes mounted on respective /bindings/ path\n        volumeMounts:\n        - mountPath: /bindings/xsuaa-api/\n          name: "xsuaa-api"\n          readOnly: true\n      ...\n      # SAP BTP Service Binding Secrets provided as volumes\n      volumes:\n      - name: xsuaa-api\n        secret:\n          secretName: susaas-broker-xsuaa-api\n')),(0,r.kt)("h2",{id:"service"},"Service"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more")," - ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/services-networking/service/"},"https://kubernetes.io/docs/concepts/services-networking/service/"))),(0,r.kt)("p",null,"A Kubernetes Service provides a stable communication interface for your workloads and can have various facets. While our scenario is using the default Service type called Cluster IP (stable internal IP within the Cluster), there are also other Service types like Load Balancer. A Load Balancer Service assigns a static external IP to your workloads, while a Cluster IP Service uses an internal IP range only. "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"While your workloads typically consist of multiple Pods (which all have different and changing internal IP addresses), a Cluster IP Service provides a stable internal IP address and load-balances traffic to the various Pods of your target workload (e.g., in a Round Robin approach). ")),(0,r.kt)("p",null,"For our scenario, internal IP addresses are sufficient, as all external traffic targeting our workloads is handled by ",(0,r.kt)("a",{parentName:"p",href:"#istio-service-mesh"},"Istio")," Ingress Gateway. Therefore, our Cluster only requires one single Service Instance of type Load Balancer, which is used by ",(0,r.kt)("a",{parentName:"p",href:"#istio-service-mesh"},"Istio")," Ingress Gateway. Once the traffic has passed through the Gateway, the requests are internally routed to the respective Cluster IP Service instances based on the initial target host. "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"On the one hand, this allows us to leverage the powerful ",(0,r.kt)("a",{parentName:"p",href:"#istio-service-mesh"},"Istio")," features, on the other hand we also save a lot of money compared to reserving external IP addresses for all of our workloads! ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Service\nmetadata:\n  name: susaas-api\nspec:\n  # Workload selector defining the traffic targets\n  selector:\n    app.kubernetes.io/name: api\n  ports:\n    - port: 5000\n      targetPort: 5000\n      protocol: TCP\n")),(0,r.kt)("h2",{id:"service-account"},"Service Account"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more")," - ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/"},"https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/"),"    ")),(0,r.kt)("p",null,"A Service Account allows us to a assign a so-called identity to processes running in our workloads. Using this identity and its permissions, processes can e.g., interact with the Cluster API at runtime. In our sample use-case, this is required as part of the subscription process, to create new ",(0,r.kt)("a",{parentName:"p",href:"#api-rule"},"API Rules")," at runtime, using the SaaS Backend Service. If no dedicated Service Account is assigned to a workload, the ",(0,r.kt)("strong",{parentName:"p"},"default")," Service Account is used. Below you can find the definition of a dedicated Service Account used by the SaaS Backend Service workloads."),(0,r.kt)("p",null,"You can grant custom permissions to a Service Account using existing or new ",(0,r.kt)("a",{parentName:"p",href:"#cluster-role"},"Cluster Role")," definitions. These ",(0,r.kt)("a",{parentName:"p",href:"#cluster-role"},"Cluster Roles")," can be bound to a Service Account using ",(0,r.kt)("a",{parentName:"p",href:"#role-binding"},"Role Bindings"),". Service Accounts are attached to workloads as part of the ",(0,r.kt)("a",{parentName:"p",href:"#deployment"},"Deployment")," definition (see sample below). If required, the so called Service Account Token can be ",(0,r.kt)("strong",{parentName:"p"},"auto-mounted"),". This enables your workload processes to interact with your Cluster API on-behalf of the Service Account."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  # Name of the Service Account to be created\n  name: susaas-srv\n")),(0,r.kt)("p",null,"Sample of a ",(0,r.kt)("a",{parentName:"p",href:"#deployment"},"Deployment")," definition using a dedicated Service Account, as well as the mentioned ",(0,r.kt)("strong",{parentName:"p"},"auto-mount")," feature. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: susaas-srv\nspec:\n  selector:\n    matchLabels:\n      app.kubernetes.io/name: srv\n  template:\n    metadata:\n      labels:\n        app.kubernetes.io/name: srv\n    spec:\n      # Enables the auto-mount feature of the Service Account Token\n      automountServiceAccountToken: true\n      # Assign a dedicated Service Account to the workload\n      serviceAccountName: susaas-srv\n      containers:\n        - image: sapse/susaas-srv:latest\n        ...\n")),(0,r.kt)("h2",{id:"service-binding"},"Service Binding"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"https://help.sap.com/docs/btp/sap-business-technology-platform/using-sap-btp-services-in-kyma-environment"},"https://help.sap.com/docs/btp/sap-business-technology-platform/using-sap-btp-services-in-kyma-environment"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"https://blogs.sap.com/2022/07/12/the-new-way-to-consume-service-bindings-on-kyma-runtime/"},"https://blogs.sap.com/2022/07/12/the-new-way-to-consume-service-bindings-on-kyma-runtime/"))),(0,r.kt)("p",null,"A Service Binding is a custom Kyma resource and simplifies the integration of SAP BTP ",(0,r.kt)("a",{parentName:"p",href:"#service-instance"},"Service Instances"),". Creating a new Service Binding resource for a corresponding ",(0,r.kt)("a",{parentName:"p",href:"#service-instance"},"Service Instances"),", will result in new Client Credentials or X.509 Certificates. These credentials or certificates will be automatically stored in Kubernetes ",(0,r.kt)("a",{parentName:"p",href:"#secret"},"Secrets"),". These ",(0,r.kt)("a",{parentName:"p",href:"#secret"},"Secrets")," can then be consumed in your workloads, by mounting them as a volume to a specific path in your containers. Check the respective documentation on ",(0,r.kt)("a",{parentName:"p",href:"#secret"},"Secrets")," to learn more. Using npm packages like @sap/xsenv, CAP can consume these bindings as you are used to from the Cloud Foundry environment. "),(0,r.kt)("p",null,"The following sample creates a Service Binding for the ",(0,r.kt)("strong",{parentName:"p"},"susaas-api-uaa")," ",(0,r.kt)("a",{parentName:"p",href:"#service-instance"},"Service Instance"),", intended to be used by the ",(0,r.kt)("strong",{parentName:"p"},"susaas-broker")," workload (as you can determine by the name)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: services.cloud.sap.com/v1\nkind: ServiceBinding\nmetadata:\n  name: susaas-broker-xsuaa-api-uaa\nspec:\n  # Service Instance for which a new Service Binding is required\n  serviceInstanceName: susaas-api-uaa\n")),(0,r.kt)("p",null,"Below, you can see a sample ",(0,r.kt)("a",{parentName:"p",href:"#secret"},"Secret"),", created by the above Service Binding. As you can see, it contains the typical Client Credentials you already know from the Cloud Foundry environment."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"kind: Secret\napiVersion: v1\nmetadata:\n  name: susaas-broker-xsuaa-api\ndata:\n  apiurl: https://api.authentication.us20.hana.ondemand.com\n  clientid: sb-susaas-api!b8342\n  clientsecret: 53e9f606-...-bb44-898903\n  credential-type: binding-secret\n  ...\ntype: Opaque\n")),(0,r.kt)("h2",{id:"service-instance"},"Service Instance"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Learn more"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"https://help.sap.com/docs/btp/sap-business-technology-platform/using-sap-btp-services-in-kyma-environment"},"https://help.sap.com/docs/btp/sap-business-technology-platform/using-sap-btp-services-in-kyma-environment"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"https://blogs.sap.com/2022/07/12/the-new-way-to-consume-service-bindings-on-kyma-runtime/"},"https://blogs.sap.com/2022/07/12/the-new-way-to-consume-service-bindings-on-kyma-runtime/"))),(0,r.kt)("p",null,"Like ",(0,r.kt)("a",{parentName:"p",href:"#service-binding"},"Service Bindings"),", also SAP BTP Service Instances are custom Kyma resources and act as kind of counterpart. Using the SAP BTP Service Manager (available in each Kyma Cluster), the usage of Service Instances allows you to create and maintain SAP BTP Service Instances from within your Cluster. The definition of such Service Instances is comparable to the mta.yaml-based definitions in the Cloud Foundry environment. "),(0,r.kt)("p",null,"Besides providing the name of the required service offering (e.g., xsuaa or hana) and corresponding plan (e.g., application or hdi-shared), you can define all required Service Instance parameters. This applies for any kind of service type available for the Kyma runtime, like the Destination Service example which you can find below. "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"If you are referencing a json file containing your instance parameters (like often done for xsuaa), please make sure the file resides in the same directory as your Helm template for this Service Instance. ")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"mdxAdmonitionTitle"},"Hint")," "),(0,r.kt)("p",{parentName:"admonition"},"Before creating Service Instances from within your Kyma Cluster, please assign the required entitlements to the respective SAP BTP subaccount. Most SAP BTP Services are available for the Kyma Runtime already, still there are a few exceptions like SAP Build Workzone. In those cases, you have to create a Service Instance in Cloud Foundry and and manually provide the generated ",(0,r.kt)("a",{parentName:"p",href:"#service-binding"},"Service Binding")," credentials as a ",(0,r.kt)("a",{parentName:"p",href:"#secret"},"Secret")," to your Kyma Cluster. ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: services.cloud.sap.com/v1\nkind: ServiceInstance\nmetadata:\n  name: susaas-dest\nspec:\n  serviceOfferingName: destination\n  servicePlanName: lite\n  externalName: susaas-dest\n  parameters:\n    HTML5Runtime_enabled: false\n    init_data:\n      instance:\n        destinations:\n        - Authentication: NoAuthentication\n          HTML5.DynamicDestination: true\n          HTML5.ForwardAuthToken: true\n          Name: susaas-srv-api\n          ProxyType: Internet\n          Type: HTTP\n          URL: http://susaas-srv:8080\n        - Authentication: NoAuthentication\n          Name: ui5\n          ProxyType: Internet\n          Type: HTTP\n          URL: https://ui5.sap.com/1.108.4\n        existing_destinations_policy: update\n    version: 1.0.0\n")))}m.isMDXComponent=!0},62099:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/IstioArchitecture-040603070065c5c8a1013a81573f9981.svg"},83794:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/IstioArchitectureDetails-48cc1d41d8816131a3bf66bd55fd78df.svg"},77127:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/KOCustomDomain-812c0aeea7ab8f6a13b86f8f9b755acf.png"},99209:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/KOKialiIstioIngress-f6ee50c6c62abad58f193275f00475c2.png"},83977:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/KymaObjectsGeneral-21d4e7fc56d23fefdb216545e99a0bc9.png"},84850:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/ResourceDetailsArch-413621d553782d75563c31cf33071cfd.png"}}]);